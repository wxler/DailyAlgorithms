## 数据结构系列

### 146. LRU 缓存机制

https://leetcode-cn.com/problems/lru-cache/

```java
class LRUCache {

    LinkedHashMap<Integer,Integer> cache=new LinkedHashMap<>();;
    int cap;
    public LRUCache(int capacity) {
        this.cap=capacity;
    }
    
    public int get(int key) {
        if(cache.containsKey(key)){
            recentUse(key);
            return cache.get(key);
        }else return -1;
    }
    
    public void put(int key, int value) {
        if(cache.containsKey(key)){
            cache.put(key,value);//别忘了重置之前的key，注意这里并不会更新key的顺序
            recentUse(key);
            return;
        }
        if(cache.size()>=cap){
            int oldKey=cache.keySet().iterator().next();
            cache.remove(oldKey);
        }
        cache.put(key,value);
    }

    public void recentUse(int key){
        int value=cache.get(key);
        cache.remove(key);//这个一定不要少，只有把cache中的key移出了，才能放到最后面，否则下面的put判断key已经存在了，不会更新key的顺序的
        cache.put(key,value); //put判断key已经存在了，不会更新key的顺序的
    }
}

/**
 * Your LRUCache object will be instantiated and called as such:
 * LRUCache obj = new LRUCache(capacity);
 * int param_1 = obj.get(key);
 * obj.put(key,value);
 */
```

注意1：put的时候如果key存在别忘了重置cache

注意2：<font color="red" size="5">在LinkedHashMap中，put时判断key都已经存在了，不会更新key的顺序的</font>

看下面的例子：

```java
LinkedHashMap<Integer,Integer> cache=new LinkedHashMap<>();;
cache.put(1, 1);
cache.put(2, 2);
cache.put(3, 3);
System.out.println(cache.keySet().toString()); //输出[1, 2, 3]
cache.put(2, 2);
System.out.println(cache.keySet().toString());//输出[1, 2, 3]，不会把2放在最后面
cache.put(2, 4);
System.out.println(cache.keySet().toString());//输出[1, 2, 3]，不会把2放在最后面
```

对于LinkedHashSet来说也是一样

```java
LinkedHashSet<Integer> set=new LinkedHashSet<>();;
set.add(1);
set.add(2);
set.add(3);
System.out.println(set.toString());//输出[1, 2, 3]
set.add(2);
System.out.println(set.toString());//输出[1, 2, 3]，不会把2放在最后面
```





### 460. LFU 缓存

https://leetcode-cn.com/problems/lfu-cache/



```java
class LFUCache {

    HashMap<Integer,Integer> keyValue=new HashMap<>();
    HashMap<Integer,Integer> keyCount=new HashMap<>();
    HashMap<Integer,LinkedHashSet<Integer>> countKey=new HashMap<>();
    int minCount=0;
    int cap;

    public LFUCache(int capacity) {
        this.cap=capacity;
    }
    
    public int get(int key) {
        if(cap==0) return -1;
        if(keyValue.containsKey(key)){
            updateCount(key);
            return keyValue.get(key);
        }else return -1;
    }
    
    public void put(int key, int value) {
        if(cap==0) return;
        if(keyValue.containsKey(key)){
            keyValue.put(key,value);
            updateCount(key);
            return;
        }
        if(keyValue.size()>=cap){
            //移出最少count的最久的key
            LinkedHashSet<Integer> keySet=countKey.get(minCount);
            int oldKey=keySet.iterator().next();
            keySet.remove(oldKey);
            if(keySet.isEmpty()) {
                countKey.remove(minCount);//这里不用更新minF,因为下面minF就置为1了
            }
            
            keyCount.remove(oldKey);
            keyValue.remove(oldKey);
        }

        keyValue.put(key,value);
        keyCount.put(key,1);
        LinkedHashSet<Integer> keySet=countKey.getOrDefault(1,new LinkedHashSet<Integer>());
        keySet.add(key);
        countKey.put(1,keySet);
        minCount=1;     
    }

    public void updateCount(int key){
        int count=keyCount.get(key);
        //移出count
        //keyCount.remove(key);//这个有没有都行，因为下面有keyCount.put(key,count+1);
        LinkedHashSet<Integer> keySet=countKey.get(count);
        keySet.remove(key);
        if(keySet.isEmpty()){
            if(count==minCount){//如果移除count后set为空，此时若移出的是minCount，则把minCount加一，一定要记住啊
                minCount++;
            }
            countKey.remove(count);
        }
        
        //添加count
        keyCount.put(key,count+1);

        LinkedHashSet<Integer> newkeySet=countKey.getOrDefault(count+1,new LinkedHashSet<Integer>());
        newkeySet.add(key);
        countKey.put(count+1,newkeySet);

    }
}

/**
 * Your LFUCache object will be instantiated and called as such:
 * LFUCache obj = new LFUCache(capacity);
 * int param_1 = obj.get(key);
 * obj.put(key,value);
 */
```



注意1：如果移除count后set为空，此时若移出的是minCount，则把minCount加一，一定要记住啊

<font color="red" size="5">注意2：`countKey.getOrDefault(count+1,new LinkedHashSet<Integer>()).add(key)` 没有把count+1的key添加到countKey中，一定要执行下面的：</font>

```java
LinkedHashSet<Integer> newkeySet=countKey.getOrDefault(count+1,new LinkedHashSet<Integer>());
newkeySet.add(key);
countKey.put(count+1,newkeySet);
```













## 875. 爱吃香蕉的珂珂

https://leetcode-cn.com/problems/koko-eating-bananas/



```java
class Solution {
    public int minEatingSpeed(int[] piles, int h) {

        if(piles.length==1){
            return (int)Math.ceil(piles[0]/(h*1.0));
        }

        int min=Integer.MAX_VALUE,max=Integer.MIN_VALUE;
        for(int t:piles){
            if(t<min) min=t;
            if(t>max) max=t;
        }

        int left=1,right=max;
        while(left<=right){
            int mid=left+(right-left)/2;
            if(canFinsh(piles,h,mid)){
                right=mid-1;
            }else{
                left=mid+1;
            }
        }


        return left;

    }


    public boolean canFinsh(int[] piles, int h,int speed){
        int cost=0;

        for(int i=0;i<piles.length;i++){
            cost+=(int)Math.ceil(piles[i]/(speed*1.0));
        }
        return cost<=h;
    }
}
```





## 1011. 在 D 天内送达包裹的能力

https://leetcode-cn.com/problems/capacity-to-ship-packages-within-d-days/



```java
class Solution {
    public int shipWithinDays(int[] weights, int days) {

        int min=weights[0],sum=0;
        for(int w:weights)
            sum+=w;

        if(days==1 || weights.length==1) return sum;
        
        int left=min,right=sum;
        while(left<=right){
            int mid=left+(right-left)/2;
            if(canFinsh(weights,days,mid)){
                right=mid-1;
            }else{
                left=mid+1;
            }
        }
        
        return left;
    }
    
    public boolean canFinsh(int[] weights, int days,int minPack){
        //if(sum<=minPack) return true;

        int cost=0;
        int pack=0;

        for(int i=0;i<weights.length;){
            if(weights[i]>minPack) return false;
            pack+=weights[i];
            if(pack<=minPack){
                i++;
            }else{
                cost++;
                pack=0;
            }
        }
        cost++;

        return cost<=days;
    }
}
```



## 42. 接雨水

https://leetcode-cn.com/problems/trapping-rain-water/



```java
class Solution {
    public int trap(int[] height) {

        if(height.length<=2) return 0;
        
        int n=height.length;
        int[] left_max=new int[n];
        int[] right_max=new int[n];
        left_max[0]=height[0];
        right_max[n-1]=height[n-1];

        for(int i=1;i<n;i++){
            left_max[i]=Math.max(left_max[i-1],height[i]);
        }
        for(int j=n-2;j>=0;j--){
            right_max[j]=Math.max(right_max[j+1],height[j]);
        }
        
        int sum=0;
        for(int i=1;i<=n-2;i++){
            sum+=Math.min(left_max[i],right_max[i])-height[i];
        }
        return sum;


    }
}
```



## 26. 删除有序数组中的重复项



https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array/submissions/

```java
class Solution {
    public int removeDuplicates(int[] nums) {
        
        int slow=0,fast=1;
        while(fast<nums.length){
            if(nums[slow]!=nums[fast]){
                slow++;
                nums[slow]=nums[fast];
            }
            fast++;
        }
        return slow+1;
    }
}
```



## 83. 删除排序链表中的重复元素

https://leetcode-cn.com/problems/remove-duplicates-from-sorted-list/submissions/



```java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode() {}
 *     ListNode(int val) { this.val = val; }
 *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */
class Solution {
    public ListNode deleteDuplicates(ListNode head) {
        if(head==null) return null;
        
        ListNode slow=head,fast=head.next;
        while(fast!=null){
            if(slow.val!=fast.val){
                slow.next=fast;
                slow=slow.next;
            }
            fast=fast.next;
        }
        slow.next=null;
        return head;

    }
}
```



## 82. 删除排序链表中的重复元素 II

https://leetcode-cn.com/problems/remove-duplicates-from-sorted-list-ii/







```java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode() {}
 *     ListNode(int val) { this.val = val; }
 *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */
class Solution {
    public ListNode deleteDuplicates(ListNode head) {
        if(head==null) return null;

        ListNode newHead=new ListNode(Integer.MIN_VALUE);
        newHead.next=head;
        ListNode pre=newHead,cur=pre.next;
        while(cur!=null && cur.next!=null){
            if(cur.val!=cur.next.val){
                pre=cur;
                cur=cur.next;
            }else{
                while(cur.next!=null && cur.val==cur.next.val)
                    cur=cur.next;
                
                pre.next=cur.next; //注意啊，这里pre没有变，只是pre.next变了
                cur=null;
                if(pre.next!=null) cur=pre.next;
            }
        }
        return newHead.next;


    }
}
```





## 55. 跳跃游戏

https://leetcode-cn.com/problems/jump-game/



```java
class Solution {
    public boolean canJump(int[] nums) {

        int max=0;
        for(int i=0;i<nums.length-1;i++){
            max=Math.max(max,i+nums[i]);
            if(max<=i) return false;
        }
        
        return true;
    }
}
```



## 45. 跳跃游戏 II

https://leetcode-cn.com/problems/jump-game-ii/

这是自己做的，没有看书上的答案

```java
class Solution {
    public int jump(int[] nums) {

        int n=nums.length;
        //dp: 从nums[0]跳到nums[i]的最少次数，注意dp下标
        int[] dp=new int[n+1];
        for(int i=1;i<=n;i++) dp[i]=Integer.MAX_VALUE;
        dp[1]=0;
        for(int i=2;i<=n;i++){
            for(int j=1;j<i;j++){
                if(nums[j-1]+j>=i){
                    dp[i]=Math.min(dp[i],dp[j]+1);
                }
            }
        }

        return dp[n];
    }
}
```





## 1306. 跳跃游戏 III

https://leetcode-cn.com/problems/jump-game-iii/



问题1：如果一个节点标记为走过了，但是这个结点是到达目的地的结点之一，这样该怎么办？

答：不会出现这种情况，因为你想啊，如果一个节点标记为visited，那么这个节点肯定在之前遍历过了，如果这个结点是到达目的地的结点之一，那么从这个结点起就可以找到目的地。（注意：**标记结点的目的是不能走回头路，只要存在到达目的地的路径，那么一定不会错过**）

问题2：这个求得的结果是最短路径吗？

答：**是最短路径，一定是最短路径**



```java
class Solution {
    public boolean canReach(int[] arr, int start) {
        if(arr.length==1){
            if(start==0 && arr[0]==0) return true;
            else return false;
        }

        HashMap<Integer,Integer> map=new HashMap<>();
        for(int i=0;i<arr.length;i++){
            if(arr[i]==0) map.put(i,0);
        }
        if(map.containsKey(start)) return true;

        HashSet<Integer> visited=new HashSet<>();
        Queue<Integer> queue=new LinkedList<>();
        
        queue.offer(start);
        visited.add(start);

        while(!queue.isEmpty()){

            int sz=queue.size();
            for(int i=0;i<sz;i++){
                int cur=queue.poll();
                if(map.containsKey(cur)) return true;
                
                int left=cur-arr[cur];
                int right=cur+arr[cur];
                if(left>=0 && !visited.contains(left)){
                    queue.offer(left);
                    visited.add(left);
                }

                if(right<=arr.length-1 && !visited.contains(right)){
                    queue.offer(right);
                    visited.add(right);
                }
            }
        }

        return false;
    }
}
```





## LCP 09. 最小跳跃次数

https://leetcode-cn.com/problems/zui-xiao-tiao-yue-ci-shu/



原始BFS，超时

```java
class Solution {
    public int minJump(int[] jump) {
        HashSet<Integer> visited=new HashSet<>();
        Queue<Integer> queue=new LinkedList<>();
        
        queue.offer(0);
        visited.add(0);
        

        int count=0;
        while(!queue.isEmpty()){

            int sz=queue.size();
            for(int i=0;i<sz;i++){
                int cur=queue.poll();
                if(cur>=jump.length) return count;
                

                int right=cur+jump[cur];
                if(!visited.contains(right)){
                    queue.offer(right);
                    visited.add(right);
                }

                for(int left=0;left<cur;left++){
                    if(left>=0 && !visited.contains(left)){
                        queue.offer(left);
                        visited.add(left);
                    }
                }
            }
            count++;
        }

        return count;
    }
}
```

优化后：

```java
class Solution {
    public int minJump(int[] jump) {
        HashSet<Integer> visited=new HashSet<>();
        Queue<Integer> queue=new LinkedList<>();
        
        queue.offer(0);
        visited.add(0);

        HashMap<Integer,Integer> mapMax=new HashMap<>();//记录最大值出现的次数

        int max=0;//记录已经拜访的最大值

        int count=0;
        while(!queue.isEmpty()){

            int sz=queue.size();
            for(int i=0;i<sz;i++){
                int cur=queue.poll();
                if(cur>=jump.length) return count;

                int right=cur+jump[cur];
                if(!visited.contains(right)){
                    queue.offer(right);
                    visited.add(right);
                }

                for(int left=max;left<cur;left++){
                    if(left>=0 && !visited.contains(left)){
                        queue.offer(left);
                        visited.add(left);
                    }
                    max=Math.max(max,cur);
                }
            }
            count++;
        }

        return count;
    }
}
```



## 1696. 跳跃游戏 VI

https://leetcode-cn.com/problems/jump-game-vi/

dp数组动态规划，超时

```java
class Solution {
    public int maxResult(int[] nums, int k) {

        if(nums.length<=1) return nums[0];

        int n=nums.length;
        //dp:[0..i]的最大得分
        int[] dp=new int[n];
        Arrays.fill(dp,Integer.MIN_VALUE);
        dp[0]=nums[0];
        for(int i=1;i<n;i++){
            int m=(i-k)<0?0:(i-k);
            for(;m<i;m++){
                dp[i]=Math.max(dp[i],dp[m]+nums[i]);
            }
        }

        return dp[n-1];

    }
}
```

优化后的：

```java

class Solution {

    class MonoDeque{
        Deque<Integer> q=new LinkedList<>();
        
        public void push(int value){
            while(!q.isEmpty() && q.peekLast()<value){
                q.pollLast();
            }
            q.offerLast(value);
        }

        public void pop(int value){
            if(value==q.peekFirst()){
                q.pollFirst();
            }
        }
        
        public int max(){
            return q.peekFirst();
        }
    }

    public int maxResult(int[] nums, int k) {

        if(nums.length<=1) return nums[0];

        int n=nums.length;
        //dp:[0..i]的最大得分
        int[] dp=new int[n];
        Arrays.fill(dp,Integer.MIN_VALUE);
        dp[0]=nums[0];

        //用单调队列记录前k个最大值
        MonoDeque mono=new MonoDeque();

        for(int i=1;i<n;i++){
            mono.push(dp[i-1]);
            dp[i]=Math.max(dp[i],mono.max()+nums[i]);
            if(i-k>=0) mono.pop(dp[i-k]); //注意，到这里让队列中最多剩k-1个元素就行
        }

        return dp[n-1];

    }
}
```







注意：下**面单调栈的数据结构是错的**（我的一个坑），看labuladong P275

```java
    class MonoDeque{
        Deque<Integer> queue=new LinkedList<>();
        int cap;
        public MonoDeque(int k){
            this.cap=k;
        }

        public void add(int value){
            while(!queue.isEmpty()&&queue.peekLast()<=value){
                queue.pollLast();
            }
            queue.offerLast(value);
            if(queue.size()>cap) queue.pollFirst();
        }

        public int get(){
            return queue.peekFirst();
        }
    }
```





## 区间调度问题

labuladong p381

解决一个很经典的贪心算法问题 Interval Scheduling（区间调度问题）。给你很多形如 [start, end] 的闭区间，请你设计一个算法，算出这些区间中最多有几个互不相交的区间。

```java
int intervalSchedule(int[][] intvs) {}
```

举个例子，`intvs = [[1,3], [2,4], [3,6]]`，这些区间最多有 2 个区间互不相交，即 [[1,3], [3,6]]，你的算法应该返回 2。注意边界相同并不算相交。

这个问题在生活中的应用广泛，比如你今天有好几个活动，每个活动都可以用区间 [start, end] 表示开始和结束的时间，请问你今天最多能参加几个活动呢？显然你一个人不能同时参加两个活动，所以说这个问题就是求这些时间区间的最大不相交子集。

```java
import java.util.Arrays;
import java.util.Comparator;

public class Main {

	public static void main(String[] args) {
		int[][] intvs={{1,3},{2,4},{3,6}};
		System.out.println(intervalSchedule(intvs));
	}


	public static int intervalSchedule(int[][] intvs) {
		if(intvs.length==0) return 0;

		Arrays.sort(intvs,new Comparator<int[]>(){
			public int compare(int[] a,int[] b){
				return a[1]-b[1];
			}
		});

		int count=1;
		int end=intvs[0][1];
		for(int i=1;i<intvs.length;i++){
			int[] arr=intvs[i];
			if(arr[0]>=end){ 
				count++;
				end=arr[1]; //注意，这里一定是等于arr[1]
			}
		}
		return count;
	}
}

```



## 435. 无重叠区间

https://leetcode-cn.com/problems/non-overlapping-intervals/



```java
class Solution {
    public int eraseOverlapIntervals(int[][] intervals) {
        if(intervals.length<=0) return 0;
        int n=intervals.length;
        return n-intarValMaxSub(intervals);
    }

    public int intarValMaxSub(int[][] intervals){
        Arrays.sort(intervals,new Comparator<int[]>(){
            public int compare(int[] a,int[] b){
                return a[1]-b[1];
            }
        });

        int count=1;
        int end=intervals[0][1];
        for(int i=1;i<intervals.length;i++){
            int[] arr=intervals[i];
            if(arr[0]>=end){
                count++;
                end=arr[1];
            }
        }       
        return count;
    }
}
```



## 用最少数量的箭引爆气球

**注意**

最近新增了Test Case， [[-2147483646,-2147483645],[2147483646,2147483647]] 就过不了了，这是因为差值过大而产生溢出。sort的时候不要用a-b来比较，要用Integer.compare(a, b)!!!

```java
class Solution {
    public int findMinArrowShots(int[][] points) {
        if(points.length<=0) return 0;
        
        Arrays.sort(points,new Comparator<int[]>(){
            public int compare(int[] a,int[] b){
                //return a[1]-b[1];
                return Integer.compare(a[1],b[1]);
            }
        });

        int count=1;
        int end=points[0][1];
        for(int i=1;i<points.length;i++){
            int[] arr=points[i];
            if(arr[0]>end){
                count++;
                end=arr[1];
            }
        }

        return count;
    }
    
}
```



## 20. 有效的括号

https://leetcode-cn.com/problems/valid-parentheses/



```java
class Solution {
    public boolean isValid(String s) {
        Stack<Character> stack=new Stack<>();
        for(char c:s.toCharArray()){
            if(c=='(' || c=='{' || c=='['){
                stack.push(c);
                continue;
            }
            if(!stack.isEmpty() && rightOf(stack.peek())==c){
                stack.pop();
            }else return false;
        }

        return stack.isEmpty();
    }

    public char rightOf(char c){
        if(c=='(') return ')';
        if(c=='{') return '}';
        if(c=='[') return ']';
        return '_';
    }
}
```





## 补充：

### 160. 相交链表

https://leetcode-cn.com/problems/intersection-of-two-linked-lists/



```java
public class Solution {
    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {
        HashSet<ListNode> set=new HashSet<>();
        while(headA!=null){
            set.add(headA);
            headA=headA.next;
        }

        while(headB!=null){
            if(set.contains(headB)) return headB;
            headB=headB.next;
        }

        return null;
    }
}
```



### 剑指 Offer 34. 二叉树中和为某一值的路径

https://leetcode-cn.com/problems/er-cha-shu-zhong-he-wei-mou-yi-zhi-de-lu-jing-lcof/

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    
    public List<List<Integer>> pathSum(TreeNode root, int target) {

        List<List<Integer>> res=new ArrayList<>();

        List<Integer> r=new ArrayList<>();
        if(root==null){
            //res.add(r);
            return res;
        }

        if(root.left==null && root.right==null){
            if(root.val==target){
                r.add(root.val);
                res.add(r);
               // System.out.print(target+","+root.val+",aa,");
            }
          //  System.out.print(target+","+root.val+",bb,");
            return res;
        }

        List<List<Integer>> left=null,right=null;
        if(root.left!=null){
            left=pathSum(root.left,target-root.val);
            if(left.size()>0){
                for(List<Integer> path:left){
                    List<Integer> temp=new ArrayList<Integer>();
                    temp.add(root.val);
                    temp.addAll(path);
                    res.add(temp);
                }
            }
        }

        if(root.right!=null){
            right=pathSum(root.right,target-root.val);
            if(right.size()>0){
                for(List<Integer> path:right){
                    List<Integer> temp=new ArrayList<Integer>();
                    temp.add(root.val);
                    temp.addAll(path);
                    res.add(temp);
                }
            }            
        }
        
        return res;

    }
}
```



另外一种方法（**调试了好久**）

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    List<List<Integer>> res=new ArrayList<>();
    public List<List<Integer>> pathSum(TreeNode root, int target) {
        if(root==null) return res;
        List<Integer> path=new ArrayList<>();
        findPath(root,target,0,path);
        return res;
    }

    public void findPath(TreeNode root,int target,int sum,List<Integer> path){
        if(root.left==null && root.right==null){
            path.add(root.val);//不能把path.add(root.val)写在下面的if里，否则报错
            if((sum+root.val)==target){
                List<Integer> temp=new ArrayList<>(path);
                //System.out.print(temp.toString()+",");
                res.add(temp);
            }
            return;
        }
        sum=sum+root.val;
        path.add(root.val);

        if(root.left!=null){
            //path.add(root.left.val);//这个不能有，一次只能一个path
            findPath(root.left,target,sum,path);
            path.remove(path.size()-1);
        }

        if(root.right!=null){
            findPath(root.right,target,sum,path);
            path.remove(path.size()-1);
        }

    }
}
```

错误1：**记得回溯的状态，到底添加了啥，没添加啥**

错误2：肯定不能有两个path.add，这不就重复了

<font color="red" size="7">回溯法的核心思想：先添加再说，这样才能保证移除的正确性</font>

**就是下面的做法，不要搞混了：**

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    List<List<Integer>> res=new ArrayList<>();
    public List<List<Integer>> pathSum(TreeNode root, int target) {
        if(root==null) return res;
        List<Integer> path=new ArrayList<>();
        path.add(root.val);
        int sum=root.val;
        findPath(root,target,sum,path);
        return res;
    }

    public void findPath(TreeNode root,int target,int sum,List<Integer> path){
        if(root.left==null && root.right==null){
            if(sum==target){
                List<Integer> temp=new ArrayList<>(path);
                res.add(temp);
            }
            return;
        }

        if(root.left!=null){
            path.add(root.left.val);
            findPath(root.left,target,sum+root.left.val,path);
            path.remove(path.size()-1);
        }

        if(root.right!=null){
            path.add(root.right.val);
            findPath(root.right,target,sum+root.right.val,path);
            path.remove(path.size()-1);
        }

    }
}
```

