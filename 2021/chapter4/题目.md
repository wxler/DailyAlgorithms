

## 875. 爱吃香蕉的珂珂

https://leetcode-cn.com/problems/koko-eating-bananas/



```java
class Solution {
    public int minEatingSpeed(int[] piles, int h) {

        if(piles.length==1){
            return (int)Math.ceil(piles[0]/(h*1.0));
        }

        int min=Integer.MAX_VALUE,max=Integer.MIN_VALUE;
        for(int t:piles){
            if(t<min) min=t;
            if(t>max) max=t;
        }

        int left=1,right=max;
        while(left<=right){
            int mid=left+(right-left)/2;
            if(canFinsh(piles,h,mid)){
                right=mid-1;
            }else{
                left=mid+1;
            }
        }


        return left;

    }


    public boolean canFinsh(int[] piles, int h,int speed){
        int cost=0;

        for(int i=0;i<piles.length;i++){
            cost+=(int)Math.ceil(piles[i]/(speed*1.0));
        }
        return cost<=h;
    }
}
```





## 1011. 在 D 天内送达包裹的能力

https://leetcode-cn.com/problems/capacity-to-ship-packages-within-d-days/



```java
class Solution {
    public int shipWithinDays(int[] weights, int days) {

        int min=weights[0],sum=0;
        for(int w:weights)
            sum+=w;

        if(days==1 || weights.length==1) return sum;
        
        int left=min,right=sum;
        while(left<=right){
            int mid=left+(right-left)/2;
            if(canFinsh(weights,days,mid)){
                right=mid-1;
            }else{
                left=mid+1;
            }
        }
        
        return left;
    }
    
    public boolean canFinsh(int[] weights, int days,int minPack){
        //if(sum<=minPack) return true;

        int cost=0;
        int pack=0;

        for(int i=0;i<weights.length;){
            if(weights[i]>minPack) return false;
            pack+=weights[i];
            if(pack<=minPack){
                i++;
            }else{
                cost++;
                pack=0;
            }
        }
        cost++;

        return cost<=days;
    }
}
```



## 42. 接雨水

https://leetcode-cn.com/problems/trapping-rain-water/



```java
class Solution {
    public int trap(int[] height) {

        if(height.length<=2) return 0;
        
        int n=height.length;
        int[] left_max=new int[n];
        int[] right_max=new int[n];
        left_max[0]=height[0];
        right_max[n-1]=height[n-1];

        for(int i=1;i<n;i++){
            left_max[i]=Math.max(left_max[i-1],height[i]);
        }
        for(int j=n-2;j>=0;j--){
            right_max[j]=Math.max(right_max[j+1],height[j]);
        }
        
        int sum=0;
        for(int i=1;i<=n-2;i++){
            sum+=Math.min(left_max[i],right_max[i])-height[i];
        }
        return sum;


    }
}
```



## 26. 删除有序数组中的重复项



https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array/submissions/

```java
class Solution {
    public int removeDuplicates(int[] nums) {
        
        int slow=0,fast=1;
        while(fast<nums.length){
            if(nums[slow]!=nums[fast]){
                slow++;
                nums[slow]=nums[fast];
            }
            fast++;
        }
        return slow+1;
    }
}
```



## 83. 删除排序链表中的重复元素

https://leetcode-cn.com/problems/remove-duplicates-from-sorted-list/submissions/



```java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode() {}
 *     ListNode(int val) { this.val = val; }
 *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */
class Solution {
    public ListNode deleteDuplicates(ListNode head) {
        if(head==null) return null;
        
        ListNode slow=head,fast=head.next;
        while(fast!=null){
            if(slow.val!=fast.val){
                slow.next=fast;
                slow=slow.next;
            }
            fast=fast.next;
        }
        slow.next=null;
        return head;

    }
}
```



## 82. 删除排序链表中的重复元素 II

https://leetcode-cn.com/problems/remove-duplicates-from-sorted-list-ii/







```java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode() {}
 *     ListNode(int val) { this.val = val; }
 *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */
class Solution {
    public ListNode deleteDuplicates(ListNode head) {
        if(head==null) return null;

        ListNode newHead=new ListNode(Integer.MIN_VALUE);
        newHead.next=head;
        ListNode pre=newHead,cur=pre.next;
        while(cur!=null && cur.next!=null){
            if(cur.val!=cur.next.val){
                pre=cur;
                cur=cur.next;
            }else{
                while(cur.next!=null && cur.val==cur.next.val)
                    cur=cur.next;
                
                pre.next=cur.next; //注意啊，这里pre没有变，只是pre.next变了
                cur=null;
                if(pre.next!=null) cur=pre.next;
            }
        }
        return newHead.next;


    }
}
```





## 55. 跳跃游戏

https://leetcode-cn.com/problems/jump-game/



```java
class Solution {
    public boolean canJump(int[] nums) {

        int max=0;
        for(int i=0;i<nums.length-1;i++){
            max=Math.max(max,i+nums[i]);
            if(max<=i) return false;
        }
        
        return true;
    }
}
```



## 45. 跳跃游戏 II

https://leetcode-cn.com/problems/jump-game-ii/

这是自己做的，没有看书上的答案

```java
class Solution {
    public int jump(int[] nums) {

        int n=nums.length;
        //dp: 从nums[0]跳到nums[i]的最少次数，注意dp下标
        int[] dp=new int[n+1];
        for(int i=1;i<=n;i++) dp[i]=Integer.MAX_VALUE;
        dp[1]=0;
        for(int i=2;i<=n;i++){
            for(int j=1;j<i;j++){
                if(nums[j-1]+j>=i){
                    dp[i]=Math.min(dp[i],dp[j]+1);
                }
            }
        }

        return dp[n];
    }
}
```





## 1306. 跳跃游戏 III

https://leetcode-cn.com/problems/jump-game-iii/



问题1：如果一个节点标记为走过了，但是这个结点是到达目的地的结点之一，这样该怎么办？

答：不会出现这种情况，因为你想啊，如果一个节点标记为visited，那么这个节点肯定在之前遍历过了，如果这个结点是到达目的地的结点之一，那么从这个结点起就可以找到目的地。（注意：**标记结点的目的是不能走回头路，只要存在到达目的地的路径，那么一定不会错过**）

问题2：这个求得的结果是最短路径吗？

答：**是最短路径，一定是最短路径**



```java
class Solution {
    public boolean canReach(int[] arr, int start) {
        if(arr.length==1){
            if(start==0 && arr[0]==0) return true;
            else return false;
        }

        HashMap<Integer,Integer> map=new HashMap<>();
        for(int i=0;i<arr.length;i++){
            if(arr[i]==0) map.put(i,0);
        }
        if(map.containsKey(start)) return true;

        HashSet<Integer> visited=new HashSet<>();
        Queue<Integer> queue=new LinkedList<>();
        
        queue.offer(start);
        visited.add(start);

        while(!queue.isEmpty()){

            int sz=queue.size();
            for(int i=0;i<sz;i++){
                int cur=queue.poll();
                if(map.containsKey(cur)) return true;
                
                int left=cur-arr[cur];
                int right=cur+arr[cur];
                if(left>=0 && !visited.contains(left)){
                    queue.offer(left);
                    visited.add(left);
                }

                if(right<=arr.length-1 && !visited.contains(right)){
                    queue.offer(right);
                    visited.add(right);
                }
            }
        }

        return false;
    }
}
```





## LCP 09. 最小跳跃次数

https://leetcode-cn.com/problems/zui-xiao-tiao-yue-ci-shu/



原始BFS，超时

```java
class Solution {
    public int minJump(int[] jump) {
        HashSet<Integer> visited=new HashSet<>();
        Queue<Integer> queue=new LinkedList<>();
        
        queue.offer(0);
        visited.add(0);
        

        int count=0;
        while(!queue.isEmpty()){

            int sz=queue.size();
            for(int i=0;i<sz;i++){
                int cur=queue.poll();
                if(cur>=jump.length) return count;
                

                int right=cur+jump[cur];
                if(!visited.contains(right)){
                    queue.offer(right);
                    visited.add(right);
                }

                for(int left=0;left<cur;left++){
                    if(left>=0 && !visited.contains(left)){
                        queue.offer(left);
                        visited.add(left);
                    }
                }
            }
            count++;
        }

        return count;
    }
}
```

优化后：

```java
class Solution {
    public int minJump(int[] jump) {
        HashSet<Integer> visited=new HashSet<>();
        Queue<Integer> queue=new LinkedList<>();
        
        queue.offer(0);
        visited.add(0);

        HashMap<Integer,Integer> mapMax=new HashMap<>();//记录最大值出现的次数

        int max=0;//记录已经拜访的最大值

        int count=0;
        while(!queue.isEmpty()){

            int sz=queue.size();
            for(int i=0;i<sz;i++){
                int cur=queue.poll();
                if(cur>=jump.length) return count;

                int right=cur+jump[cur];
                if(!visited.contains(right)){
                    queue.offer(right);
                    visited.add(right);
                }

                for(int left=max;left<cur;left++){
                    if(left>=0 && !visited.contains(left)){
                        queue.offer(left);
                        visited.add(left);
                    }
                    max=Math.max(max,cur);
                }
            }
            count++;
        }

        return count;
    }
}
```



## 1696. 跳跃游戏 VI

https://leetcode-cn.com/problems/jump-game-vi/

dp数组动态规划，超时

```java
class Solution {
    public int maxResult(int[] nums, int k) {

        if(nums.length<=1) return nums[0];

        int n=nums.length;
        //dp:[0..i]的最大得分
        int[] dp=new int[n];
        Arrays.fill(dp,Integer.MIN_VALUE);
        dp[0]=nums[0];
        for(int i=1;i<n;i++){
            int m=(i-k)<0?0:(i-k);
            for(;m<i;m++){
                dp[i]=Math.max(dp[i],dp[m]+nums[i]);
            }
        }

        return dp[n-1];

    }
}
```

优化后的：

```java

class Solution {

    class MonoDeque{
        Deque<Integer> q=new LinkedList<>();
        
        public void push(int value){
            while(!q.isEmpty() && q.peekLast()<value){
                q.pollLast();
            }
            q.offerLast(value);
        }

        public void pop(int value){
            if(value==q.peekFirst()){
                q.pollFirst();
            }
        }
        
        public int max(){
            return q.peekFirst();
        }
    }

    public int maxResult(int[] nums, int k) {

        if(nums.length<=1) return nums[0];

        int n=nums.length;
        //dp:[0..i]的最大得分
        int[] dp=new int[n];
        Arrays.fill(dp,Integer.MIN_VALUE);
        dp[0]=nums[0];

        //用单调队列记录前k个最大值
        MonoDeque mono=new MonoDeque();

        for(int i=1;i<n;i++){
            mono.push(dp[i-1]);
            dp[i]=Math.max(dp[i],mono.max()+nums[i]);
            if(i-k>=0) mono.pop(dp[i-k]); //注意，到这里让队列中最多剩k-1个元素就行
        }

        return dp[n-1];

    }
}
```







注意：下**面单调栈的数据结构是错的**（我的一个坑），看labuladong P275

```java
    class MonoDeque{
        Deque<Integer> queue=new LinkedList<>();
        int cap;
        public MonoDeque(int k){
            this.cap=k;
        }

        public void add(int value){
            while(!queue.isEmpty()&&queue.peekLast()<=value){
                queue.pollLast();
            }
            queue.offerLast(value);
            if(queue.size()>cap) queue.pollFirst();
        }

        public int get(){
            return queue.peekFirst();
        }
    }
```





## 区间调度问题

labuladong p381

解决一个很经典的贪心算法问题 Interval Scheduling（区间调度问题）。给你很多形如 [start, end] 的闭区间，请你设计一个算法，算出这些区间中最多有几个互不相交的区间。

```java
int intervalSchedule(int[][] intvs) {}
```

举个例子，`intvs = [[1,3], [2,4], [3,6]]`，这些区间最多有 2 个区间互不相交，即 [[1,3], [3,6]]，你的算法应该返回 2。注意边界相同并不算相交。

这个问题在生活中的应用广泛，比如你今天有好几个活动，每个活动都可以用区间 [start, end] 表示开始和结束的时间，请问你今天最多能参加几个活动呢？显然你一个人不能同时参加两个活动，所以说这个问题就是求这些时间区间的最大不相交子集。

```java
import java.util.Arrays;
import java.util.Comparator;

public class Main {

	public static void main(String[] args) {
		int[][] intvs={{1,3},{2,4},{3,6}};
		System.out.println(intervalSchedule(intvs));
	}


	public static int intervalSchedule(int[][] intvs) {
		if(intvs.length==0) return 0;

		Arrays.sort(intvs,new Comparator<int[]>(){
			public int compare(int[] a,int[] b){
				return a[1]-b[1];
			}
		});

		int count=1;
		int end=intvs[0][1];
		for(int i=1;i<intvs.length;i++){
			int[] arr=intvs[i];
			if(arr[0]>=end){ 
				count++;
				end=arr[1]; //注意，这里一定是等于arr[1]
			}
		}
		return count;
	}
}

```



## 435. 无重叠区间

https://leetcode-cn.com/problems/non-overlapping-intervals/



```java
class Solution {
    public int eraseOverlapIntervals(int[][] intervals) {
        if(intervals.length<=0) return 0;
        int n=intervals.length;
        return n-intarValMaxSub(intervals);
    }

    public int intarValMaxSub(int[][] intervals){
        Arrays.sort(intervals,new Comparator<int[]>(){
            public int compare(int[] a,int[] b){
                return a[1]-b[1];
            }
        });

        int count=1;
        int end=intervals[0][1];
        for(int i=1;i<intervals.length;i++){
            int[] arr=intervals[i];
            if(arr[0]>=end){
                count++;
                end=arr[1];
            }
        }       
        return count;
    }
}
```



## 用最少数量的箭引爆气球

**注意**

最近新增了Test Case， [[-2147483646,-2147483645],[2147483646,2147483647]] 就过不了了，这是因为差值过大而产生溢出。sort的时候不要用a-b来比较，要用Integer.compare(a, b)!!!

```java
class Solution {
    public int findMinArrowShots(int[][] points) {
        if(points.length<=0) return 0;
        
        Arrays.sort(points,new Comparator<int[]>(){
            public int compare(int[] a,int[] b){
                //return a[1]-b[1];
                return Integer.compare(a[1],b[1]);
            }
        });

        int count=1;
        int end=points[0][1];
        for(int i=1;i<points.length;i++){
            int[] arr=points[i];
            if(arr[0]>end){
                count++;
                end=arr[1];
            }
        }

        return count;
    }
    
}
```



## 20. 有效的括号

https://leetcode-cn.com/problems/valid-parentheses/



```java
class Solution {
    public boolean isValid(String s) {
        Stack<Character> stack=new Stack<>();
        for(char c:s.toCharArray()){
            if(c=='(' || c=='{' || c=='['){
                stack.push(c);
                continue;
            }
            if(!stack.isEmpty() && rightOf(stack.peek())==c){
                stack.pop();
            }else return false;
        }

        return stack.isEmpty();
    }

    public char rightOf(char c){
        if(c=='(') return ')';
        if(c=='{') return '}';
        if(c=='[') return ']';
        return '_';
    }
}
```

