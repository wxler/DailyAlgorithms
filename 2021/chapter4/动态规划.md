动态规划适用于计算**满足某种条件的序列或子串的个数**，不适用于计算满足某种条件的具体的序列或子串。当然每次把结果记录下来也是可以的。【但是这样可能有时对于不连续的序列，不太好做】

动态规划的一个技巧可以试一试，就是如果没有想到定义dp数组或者dp函数的时候，直接让输入的值等于结果，这样试试能不能做出来，比如输入3,4，输出6，dp定义为`dp[3][4]=6`，然后反推状态和dp数组的定义。就算这样不行，和这个也大差不差，估计稍微改一下就行。

**唯一原理：数学规划法**

**dp等于的结果数**=**选择的结果数**

我是不是可以首先考虑递归函数？这样的话循环几乎就不用考虑，边界也容易考虑，只用把中心放在业务逻辑上就行。甚至只根据选择就能做出来？

很得意情况下，dp函数更简单一点吧。dp函数设计的基本：**先考虑base，然后做选择越来越接近base**。 dp函数几乎都是自上而下，当然也有自下而上的dp函数。

**先考虑base，然后做选择越来越接近base**



base一般只有一行或者一列有，很少有第二行有的

> dp函数边界尽量考虑异常情况啊

# 递归和动态规划

##  换钱的最少货币数

<font color="red" size="8">下面的做每一道题都尽量回顾一遍过程</font>

- 变量的量是dp的自变量。注意，是因为做了选择肯定会发生变化，到底选择了什么呢？肯**定是选择从输入的条件中选择了一个自变量本身嘛**，注意：自变量一般是输入数组中的位置（注意，这个位置在选择时要么只能选一次，要么可以选多次），或者其它任何可以变化的量。
  <font color="red" size="4">选择的含义可以当成**拿出来（或放进去）**</font>**（这个其实就是自上而下和自下而上思维）**
- 所求的结果是dp代表的含义（或dp代表加一个条件的结果，比如以`i`结尾的最长递增子序列，以`i`到`j`结尾的。。。）
- 然后这一步**就不用管自变量的取值范围了**，直接通过选择让自变量发生变量，然后看看能不能而出dp变化后的因变量（即结果）与之前的因变量的关系

即`i`是自变量，`dp[i]`是因变量，选择了之后`i`肯定会发生变量，这时候看`dp[i]`和发生变量后的`dp[i]`（可能是`dp[i-k]`，也可能是`dp[i+k]`）之间的关系





牛客地址：https://www.nowcoder.com/practice/4e05294fc5aa4d4fa8eacef2e606e5a8?tpId=101&&tqId=33080&rp=1&ru=/ta/programmer-code-interview-guide&qru=/ta/programmer-code-interview-guide/question-ranking

解析：labuladong 1.2节



函数`dp(int aim,int[] coins)`或数组`dp[aim]`代表目标为aim的最少货币数



方法一：dp函数自上而下暴力求解

```java

import java.util.Scanner;

public class Main{
    
    public static void main(String[] args){
        Scanner sc=new Scanner(System.in);
        int n=sc.nextInt(),aim=sc.nextInt();
        int[] coins=new int[n];
        for(int i=0;i<n;i++)
            coins[i]=sc.nextInt();
        System.out.print(dp(aim,coins));
    }
    
    public static int dp(int aim,int[] coins){
        if(aim<0) return -1;
        if(aim==0) return 0;
        
        int res=Integer.MAX_VALUE;
        int solu=0;
        for(int c:coins){
            solu=dp(aim-c,coins);
            if(solu==-1) continue;
            res=Math.min(res,1+solu);
        }
        
        return res==Integer.MAX_VALUE?-1:res;
        
    }
}
```







方法二：dp函数自上而下-保存局部最优解

```java

import java.util.Scanner;
import java.util.HashMap;

public class Main{
    static HashMap<Integer,Integer> map=new HashMap<>();
    public static void main(String[] args){
        Scanner sc=new Scanner(System.in);
        int n=sc.nextInt(),aim=sc.nextInt();
        int[] coins=new int[n];
        for(int i=0;i<n;i++)
            coins[i]=sc.nextInt();
        System.out.print(dp(aim,coins));
    }
    
    public static int dp(int aim,int[] coins){
        if(aim<0) return -1;
        if(aim==0) return 0;
        
        int res=Integer.MAX_VALUE;
        int solu=0;
        for(int c:coins){
            if(map.get(aim)!=null){
                return map.get(aim);
            }
            solu=dp(aim-c,coins);
            if(solu==-1) continue;
            res=Math.min(res,1+solu);
        }
        res=res==Integer.MAX_VALUE?-1:res;
        map.put(aim,res);
        return res;
        
    }
}
```





方法三：dp数组自下而上

```java

import java.util.Scanner;
import java.util.HashMap;

public class Main{
    static HashMap<Integer,Integer> map=new HashMap<>();
    public static void main(String[] args){
        Scanner sc=new Scanner(System.in);
        int n=sc.nextInt(),aim=sc.nextInt();
        int[] coins=new int[n];
        for(int i=0;i<n;i++)
            coins[i]=sc.nextInt();
        System.out.print(func(aim,coins));
    }
    
    public static int func(int aim,int[] coins){
        int[] dp=new int[aim+1];
        for(int i=0;i<dp.length;i++){
            dp[i]=aim+1;
        }
        dp[0]=0;
        
        for(int i=1;i<dp.length;i++)
            for(int c:coins){
                if(i-c<0) continue;
                dp[i]=Math.min(dp[i],1+dp[i-c]);
            }
        return dp[aim]==aim+1?-1:dp[aim];
    }
}
```



### 另外一种思路

dp函数：

```java

import java.util.Scanner;
import java.util.HashMap;

public class Main{
    static HashMap<String,Integer> map=new HashMap<>();
    public static void main(String[] args){
        Scanner sc=new Scanner(System.in);
        int n=sc.nextInt(),aim=sc.nextInt();
        int[] coins=new int[n];
        for(int i=0;i<n;i++)
            coins[i]=sc.nextInt();
         System.out.print(dp(n-1,aim,coins));
    }
    
    //dp：表示选择coins[0...i]中的任意硬币组成aim的最少硬币数
    public static int dp(int i,int aim,int[] coins){ //超时，但正确
        
        if(aim==0){
            return 0;
        }
        
        if(i<0) return -1;
        
        String key=i+"_"+aim;
        if(map.containsKey(key)) return map.get(key);
        
        int res1=-1,res2=-1; //-1代表这种方案不行
        if(aim-coins[i]<0){//不选择
            res1=dp(i-1,aim,coins);
        }else{
            res1=dp(i-1,aim,coins);//不选择
            res2=dp(i,aim-coins[i],coins);//选择，注意硬币有任意个
            if(res2!=-1) res2=1+res2;//选择的时候要判断以前的方案是否可行，如果不可行，选择了也没用
        }
        
        
        int res=0;
        if(res1!=-1 && res2!=-1){
            res=Math.min(res1,res2);
        }else {
            res=res1==-1?res2:res1;
        }
        map.put(key,res);
        return res;
        
    }
}
```

dp数组：

```java

import java.util.Scanner;
import java.util.HashMap;

public class Main{
    static HashMap<String,Integer> map=new HashMap<>();
    public static void main(String[] args){
        Scanner sc=new Scanner(System.in);
        int n=sc.nextInt(),aim=sc.nextInt();
        int[] coins=new int[n];
        for(int i=0;i<n;i++)
            coins[i]=sc.nextInt();
        
        int[][] dp=new int[n+1][aim+1];
        for(int w=1;w<=aim;w++){
            dp[0][w]=-1;
        }
        
        for(int i=1;i<=n;i++)
            for(int j=1;j<=aim;j++){
                int res1=-1,res2=-1;
                if(j-coins[i-1]<0){//不选择
                    res1=dp[i-1][j];
                }else{
                    res1=dp[i-1][j];//不选择
                    res2=dp[i][j-coins[i-1]];//选择
                    if(res2!=-1) res2=1+res2;
                }
                int res=0;
                if(res1!=-1 && res2!=-1){
                    res=Math.min(res1,res2);
                }else {
                    res=res1==-1?res2:res1;
                }
                dp[i][j]=res;
                
            }
        System.out.println(dp[n][aim]);
        
    }
}
```

**历史遗留错误**：（尽量不要看）

错误一：边界考虑的情况，**一般dp只用第一行和第一列有base，哪有第二行有的**。所以dp函数只用考虑`i<0`。并且就是dp函数里把`i==0`的情况写了，很容易很容易出错，你看dp数组下不就错了嘛

错误二：dp函数没有判断`if(aim-coins[i])<0`，这本来就是错误的嘛

```java

import java.util.Scanner;
import java.util.HashMap;

public class Main{
    static HashMap<String,Integer> map=new HashMap<>();
    public static void main(String[] args){
        Scanner sc=new Scanner(System.in);
        int n=sc.nextInt(),aim=sc.nextInt();
        int[] coins=new int[n];
        for(int i=0;i<n;i++)
            coins[i]=sc.nextInt();
        
        int[][] dp=new int[n+1][aim+1];
        for(int w=1;w<=aim;w++){
            dp[0][w]=-1;
//             if(aim%coins[0]==0) dp[1][w]=aim/coins[0]; //这个一用就错了
//             else dp[1][w]=-1;
        }
        
        for(int i=1;i<=n;i++)
            for(int j=1;j<=aim;j++){
                int res1=-1,res2=-1;
                if(j-coins[i-1]<0){//不选择
                    res2=dp[i-1][j];
                }else{
                    if(dp[i][j-coins[i-1]]==-1) res1=-1;
                    else res1=1+dp[i][j-coins[i-1]];//选择
                    res2=dp[i-1][j];//不选择
                }
                int res=0;
                if(res1!=-1 && res2!=-1){
                    res=Math.min(res1,res2);
                }else {
                    res=res1==-1?res2:res1;
                }
                dp[i][j]=res;
                
            }
        System.out.println(dp[n][aim]);
        
        
//         System.out.print(dp(n-1,aim,coins));
    }
    
    public static int dp(int i,int aim,int[] coins){
        
        if(i==0){ 
            if(aim%coins[0]==0) return aim/coins[0];
            else return -1;
        }
        
        if(aim==0) return 0;
        
        if(aim<0) return -1;
        
        String key=i+"_"+aim;
        if(map.containsKey(key)) return map.get(key);
        //选择
        int res1=dp(i,aim-coins[i],coins);
        if(res1!=-1) res1=1+res1;
        
        //不选择
        int res2=dp(i-1,aim,coins);
        
        int res=0;
        if(res1!=-1 && res2!=-1){
            res=Math.min(res1,res2);
        }else {
            res=res1==-1?res2:res1;
        }
        map.put(key,res);
        return res;
        
    }
}
```





## 最长递增子序列

力扣地址：https://leetcode-cn.com/problems/longest-increasing-subsequence/



函数`dp(int[] nums,int index)`代表以nums[index]结尾的最长递增子序列

如果`dp(int[] nums,int index)`代表nums[0...index]数组的最长递增子序列，则这道题做不出来。一定要定义一个可以用数学归纳法做出来的函数或数组。

数学归纳法：labuladong 2.1 P97



方法一：dp函数-暴力解法

```java
class Solution {

    public int lengthOfLIS(int[] nums) {
        int[] result=new int[nums.length];

        for(int i=0;i<nums.length;i++){
            result[i]=dp(nums,i);
        }

        int max=0;
        for(int r:result)
            max=Math.max(max,r);

        return max;

    }

    // dp(int[] nums,int index)代表以index结尾的最长递增子序列的个数
    public int dp(int[] nums,int index){
        if(index==0) return 1;

        int res=Integer.MIN_VALUE;
        for(int i=0;i<=index-1;i++){
            if(nums[i]<nums[index]){
                res=Math.max(res,dp(nums,i)+1);
            }
        }

        return res==Integer.MIN_VALUE?1:res;

    }
}
```



方法二：dp函数自上而下-保存局部最优解

```java
class Solution {

    public int[] result;
    public int lengthOfLIS(int[] nums) {
        result=new int[nums.length];
        result[0]=1;

        for(int i=0;i<nums.length;i++){
            if(result[i]==0)//注意，只执行dp(nums,nums.length-1)不一定会让每个result都有值，因为dp中有判断大小那一步
                result[i]=dp(nums,i);
        }
        int max=0;
        for(int r:result)
            max=Math.max(max,r);

        return max;

    }

    public int dp(int[] nums,int index){
        if(index==0) return 1;

        int res=Integer.MIN_VALUE;
        int solu;
        for(int i=0;i<=index-1;i++){
            if(nums[i]<nums[index]){
                if(result[i]!=0) solu=result[i];
                else solu=dp(nums,i);
                res=Math.max(res,solu+1);
            }
        }

        res=res==Integer.MIN_VALUE?1:res;

        result[index]=res;
        
        return res;

    }
}
```



方法三：dp数组自下而上

```java
class Solution {

    public int lengthOfLIS(int[] nums) {

        int max=0;
        int[] result=func(nums);
        for(int r:result)
            max=Math.max(max,r);

        return max;

    }

    public int[] func(int[] nums){
        int[] dp=new int[nums.length];
        dp[0]=1;

        int max;
        for(int i=1;i<dp.length;i++){
            max=Integer.MIN_VALUE;
            for(int j=0;j<=i-1;j++){
                if(nums[j]<nums[i]){
                    max=Math.max(max,dp[j]+1);
                }
                dp[i]=max==Integer.MIN_VALUE?1:max;
            }
        }

        return dp;
    }
}
```



方法三：简洁化

```java
class Solution {

    public int lengthOfLIS(int[] nums) {

        int max=0;
        int[] result=func(nums);
        for(int r:result)
            max=Math.max(max,r);

        return max;

    }

    public int[] func(int[] nums){
        int[] dp=new int[nums.length];
        Arrays.fill(dp,1);
        
        int max;
        for(int i=1;i<dp.length;i++){
            max=Integer.MIN_VALUE;
            for(int j=0;j<=i-1;j++){
                if(nums[j]<nums[i]){
                	dp[i]=Math.max(dp[i],dp[j]+1);
                }
            }
        }

        return dp;
    }
}
```



我的思考：

```java
class Solution {
    public int lengthOfLIS(int[] nums) {
        int n=nums.length;
        int[] dp=new int[n];
        dp[0]=1;
        
        // //拿出来了nums[i]
        // if(nums[i]>nums[i-1]){
        //     dp[i]=dp[i-1]+1
        // }else dp[i]=1;

        int max=dp[0];
        for(int i=1;i<n;i++){
            int t=1;
            for(int j=0;j<i;j++){
                if(nums[i]>nums[j]){
                    t=Math.max(t,dp[j]+1);
                }
            }
            dp[i]=t;
            max=Math.max(max,dp[i]);
        }

        return max;
    }
}
```





## 俄罗斯套娃信封问题【困难】

地址：[力扣 (leetcode-cn.com)](https://leetcode-cn.com/problems/russian-doll-envelopes/)

labuladong：2.2

先按第一个值升序，第一个值相等时再按照第二个值降序，转化成一个最长递增子序列问题

```java
import java.util.Arrays;

class Solution {
    public int maxEnvelopes(int[][] envelopes) {

        Arrays.sort(envelopes,new Comparator<int[]>(){
            public int compare(int[] a1,int[] a2){
                return a1[0]==a2[0]?a2[1]-a1[1]:a1[0]-a2[0];
            }
        });
        
        int[] height=new int[envelopes.length];
        for(int i=0;i<envelopes.length;i++){
            height[i]=envelopes[i][1];
        }
        return getMaxSub(height);

    }

    public int getMaxSub(int[] nums){
        int[] result=new int[nums.length];
        result[0]=1;
        
        for(int i=1;i<nums.length;i++){
            if(result[i]==0) dp(nums,i,result);
        }
        
        int max=0;
        for(int a:result)
            max=Math.max(max,a);
        return max;
    }

    public int dp(int[] nums,int index,int[] result){
        if(index==0) return 1;

        int res=1;
        for(int i=0;i<=index-1;i++){
            if(nums[i]<nums[index]){
                if(result[i]==0)
                    res=Math.max(res,1+dp(nums,i,result));
                else res=Math.max(res,1+result[i]);
            }
        }
        result[index]=res;
        return res;
    }
}
```



当然也可以用dp数组

```java
import java.util.Arrays;

class Solution {
    public int maxEnvelopes(int[][] envelopes) {

        Arrays.sort(envelopes,new Comparator<int[]>(){
            public int compare(int[] a1,int[] a2){
                return a1[0]==a2[0]?a2[1]-a1[1]:a1[0]-a2[0];
            }
        });
        
        int[] height=new int[envelopes.length];
        for(int i=0;i<envelopes.length;i++){
            height[i]=envelopes[i][1];
        }
        return dp(height);

    }

    public int dp(int[] nums){
        int[] result=new int[nums.length];
        Arrays.fill(result,1);
        for(int i=1;i<result.length;i++){
            for(int j=0;j<=i-1;j++){
                if(nums[j]<nums[i])
                    result[i]=Math.max(result[i],1+result[j]);
            }
        }

        int max=0;
        for(int a:result)
            max=Math.max(max,a);

        return max;
    }
}
```



我的思考：

```java
class Solution {
    public int maxEnvelopes(int[][] envelopes) {

        Arrays.sort(envelopes,new Comparator<int[]>(){ //记住这里：<int[]>()
            public int compare(int[] a,int[] b){
                return a[0]==b[0]?b[1]-a[1]:a[0]-b[0];
            }
        });
        int n=envelopes.length;
        int[] nums=new int[n];
        int index=0;
        for(int[] a:envelopes)
            nums[index++]=a[1];
    
        int[] dp=new int[n];
        dp[0]=1;
        int max=dp[0];
        for(int i=1;i<n;i++){
            int t=1;
            for(int j=0;j<i;j++)
                if(nums[i]>nums[j]) t=Math.max(t,dp[j]+1);

            dp[i]=t;
            max=Math.max(max,dp[i]);
        }

        return max;
    }
}
```





## 最大子序和【简单】

地址：[53. 最大子序和 - 力扣（LeetCode） (leetcode-cn.com)](https://leetcode-cn.com/problems/maximum-subarray/)



dp[i]表示以i结尾的最大连续子序和

想一下数学归纳法，就可以解题了。





```java
class Solution {
    public int maxSubArray(int[] nums) {
        return dp(nums);
    }

    public int dp(int[] nums){
        int[] dp=new int[nums.length];
        for(int i=0;i<nums.length;i++){
            dp[i]=nums[i];
        }

        for(int i=1;i<nums.length;i++){
            dp[i]=Math.max(dp[i],nums[i]+dp[i-1]);
        }
        
        int max=Integer.MIN_VALUE;
        for(int a:dp)
            max=Math.max(max,a);

        return max;
    }
}
```

我的思考：

```java
class Solution {
    public int maxSubArray(int[] nums) {

        int n=nums.length;
        int[] dp=new int[n];//以i结尾的

        //选择（放进去）
        
        //dp[i]=Max( d[i-1]+nums[i],dp[i](初始时=num[i]) )

        for(int i=0;i<n;i++)
            dp[i]=nums[i];
            
        dp[0]=nums[0];
        int res=dp[0];
        for(int i=1;i<n;i++){
            dp[i]=Math.max(dp[i-1]+nums[i],dp[i]);
            res=Math.max(dp[i],res);
        }
        
        return res;

    }
}
```







## 最长公共子序列【中等】



力扣地址：https://leetcode-cn.com/problems/longest-common-subsequence/submissions/



### 方法一：dp函数自上而下-暴力破解

```java
class Solution {
    public int longestCommonSubsequence(String text1, String text2) {
        return dp(text1,text2,text1.length()-1,text2.length()-1);
    }

    public int dp(String s1,String s2,int i,int j){
        if(i==-1) return 0;
        if(j==-1) return 0;
        
        if(s1.charAt(i)==s2.charAt(j)){
            return 1+dp(s1,s2,i-1,j-1);
        }else{
            return Math.max(dp(s1,s2,i,j-1),
            Math.max(dp(s1,s2,i-1,j),dp(s1,s2,i-1,j-1)));
        }

    }
}
```



### 方法二：dp函数自上而下-保存中间结果

使用map就是有点废GC和内存

```java
class Solution {
    public HashMap<String,Integer> map=new HashMap<>();
    public int longestCommonSubsequence(String text1, String text2) {
        return dp(text1,text2,text1.length()-1,text2.length()-1);
    }

    public int dp(String s1,String s2,int i,int j){
        if(map.containsKey(i+"_"+j)) return map.get(i+"_"+j);
        if(i==-1) return 0;
        if(j==-1) return 0;
        
        int res=0;
        if(s1.charAt(i)==s2.charAt(j)){
            res=1+dp(s1,s2,i-1,j-1);
        }else{
            res=Math.max(dp(s1,s2,i,j-1),
            Math.max(dp(s1,s2,i-1,j),dp(s1,s2,i-1,j-1)));
        }
        map.put(i+"_"+j,res);
        return res;

    }
}
```





### 方法三：dp函数自下而上

**注意数组的边界，以及边界代表的含义，这一点和dp函数不同**



```java
class Solution {
    public int longestCommonSubsequence(String text1, String text2) {
        int m=text1.length(),n=text2.length();
        int[][] dp=new int[m+1][n+1];
        for(int i=1;i<m+1;i++)
            for(int j=1;j<n+1;j++){
                if(text1.charAt(i-1)==text2.charAt(j-1))
                    dp[i][j]=dp[i-1][j-1]+1;
                    //dp[i][j]=Math.max(dp[i-1][j],Math.max(dp[i][j-1],dp[i-1][j-1]))
                else dp[i][j]=Math.max(dp[i-1][j],dp[i][j-1]);
            }

        return dp[m][n];
    }
}
```



我的思考：

```java
class Solution {
    public int longestCommonSubsequence(String text1, String text2) {

        int m=text1.length(),n=text2.length();
        int[][] dp=new int[m+1][n+1];
        // dp[0][0]=0;
        // for(int j=1;j<=n;j++){
        //     dp[0][j]=0;
        // }

        for(int i=1;i<=m;i++)
            for(int j=1;j<=n;j++){
                if(text1.charAt(i-1)==text2.charAt(j-1)){
                    dp[i][j]=dp[i-1][j-1]+1;
                }else{
                    dp[i][j]=Math.max(dp[i-1][j-1],
                    Math.max(dp[i][j-1],dp[i-1][j])); //三种情形
                }
            }
        
        return dp[m][n];
        
        
        //选择（放）
        //text1[i]   text2[j]
        // if(text1[i]==text2[j]){
        //     dp[i][j]=dp[i-1][j-1]+1;
        // }else{
        //     dp[i][j]=Max(dp[i-1][j-1],dp[i][j-1],dp[i-1][j])
        // }
        
    }
}
```









## 编辑距离【困难】

力扣地址：https://leetcode-cn.com/problems/edit-distance/





### 方法一：dp函数

```java
class Solution {
    
    public int minDistance(String word1, String word2) {
        return dp(word1,word2,word1.length()-1,word2.length()-1);
    }

    public int dp(String s1,String s2,int i,int j){
        if(i==-1) return j+1;
        if(j==-1) return i+1;

        if(s1.charAt(i)==s2.charAt(j)){
            return dp(s1,s2,i-1,j-1);
        }else{
            return 1+Math.min(dp(s1,s2,i,j-1),
            Math.min(dp(s1,s2,i-1,j),dp(s1,s2,i-1,j-1)));
        }
    }
}
```



### 方法二：dp数组-保存中间结果

```java
class Solution {
    HashMap<String,Integer> map=new HashMap<>();
    public int minDistance(String word1, String word2) {
        return dp(word1,word2,word1.length()-1,word2.length()-1);
    }

    public int dp(String s1,String s2,int i,int j){
        if(map.containsKey(i+"_"+j)) return map.get(i+"_"+j);
        if(i==-1) return j+1;
        if(j==-1) return i+1;

        int res=0;
        if(s1.charAt(i)==s2.charAt(j)){
            res=dp(s1,s2,i-1,j-1);
        }else{
            res=1+Math.min(dp(s1,s2,i,j-1),
            Math.min(dp(s1,s2,i-1,j),dp(s1,s2,i-1,j-1)));
        }
        map.put(i+"_"+j,res);
        return res;
    }
}
```



### 方法三：dp数组

**注意数组的边界，以及边界代表的含义，这一点和dp函数不同**

```java
class Solution {

    public int minDistance(String word1, String word2) {
        int m=word1.length(),n=word2.length();
        int[][] dp=new int[m+1][n+1];
        for(int i=0;i<=m;i++){
            dp[i][0]=i;
        }
        for(int j=0;j<=n;j++){
            dp[0][j]=j;
        }
        
        for(int i=1;i<=m;i++)
            for(int j=1;j<=n;j++){
                if(word1.charAt(i-1)==word2.charAt(j-1)){
                    dp[i][j]=dp[i-1][j-1];
                }else{
                    dp[i][j]=1+Math.min(dp[i][j-1],
                    Math.min(dp[i-1][j],dp[i-1][j-1]));
                }
            }

        return dp[m][n];

    }
}
```









## 最小编辑代价

地址：https://www.nowcoder.com/practice/dfa502cf6a914fb5b98c59c56619e96c?tpId=101&&tqId=33111&rp=1&ru=/ta/programmer-code-interview-guide&qru=/ta/programmer-code-interview-guide/question-ranking

`dp(i,j)`表示`s1[0..i]`和`s2[0...j]`的编辑代价



我的思考：

```java
import java.util.Scanner;
import java.util.HashMap;
public class Main{
    static HashMap<String,Integer> memo=new HashMap<String,Integer>();
    static String s1,s2;
    static int[] cost=new int[3];
    public static void main(String[] args){
        Scanner sc=new Scanner(System.in);
        s1=sc.next();
        s2=sc.next();
        for(int i=0;i<3;i++)
            cost[i]=sc.nextInt();
        
        
        int m=s1.length(),n=s2.length();
        int[][] dp=new int[m+1][n+1];
        
        dp[0][0]=0;
        for(int j=1;j<=n;j++){//只能插入
            dp[0][j]=j*cost[0];
        }
        
        for(int i=1;i<=m;i++){//只能删除
            dp[i][0]=i*cost[1];
        }
        
        for(int i=1;i<=m;i++)
            for(int j=1;j<=n;j++){
                if(s1.charAt(i-1)==s2.charAt(j-1)){
                    dp[i][j]=dp[i-1][j-1];
                }else{
                    dp[i][j]=Math.min(cost[0]+dp[i][j-1],
                                      Math.min(cost[1]+dp[i-1][j],cost[2]+dp[i-1][j-1]));
                }
            }
        System.out.println(dp[m][n]);
    }
    
    
}
```







##  最长回文子序列【中等】

力扣地址：https://leetcode-cn.com/problems/longest-palindromic-subsequence/



```java
class Solution {
    public int longestPalindromeSubseq(String s) {
        int n=s.length();
        int[][] dp=new int[n][n];
        for(int i=0;i<n;i++)
            dp[i][i]=1;
        for(int i=0;i<n;i++)
            for(int j=0;j<i;j++){
                dp[i][j]=0;
            }
        
        for(int i=n-2;i>=0;i--)
            for(int j=i+1;j<n;j++){
                if(s.charAt(i)==s.charAt(j)){
                    dp[i][j]=dp[i+1][j-1]+2;//注意是+2
                }else{
                    dp[i][j]=Math.max(dp[i][j-1],dp[i+1][j]);
                }
            }
        
        return dp[0][n-1];
    }
}
```

我的思考：

```java
class Solution {
    public int longestPalindromeSubseq(String s) {

        int n=s.length();
        int[][] dp=new int[n+1][n+1];

        for(int i=1;i<=n;i++){
            dp[i][i]=1;
        }
        for(int i=n-1;i>=1;i--)
            for(int j=i+1;j<=n;j++){
                if(s.charAt(i-1)==s.charAt(j-1)){
                    dp[i][j]=dp[i+1][j-1]+2;
                }else{
                    dp[i][j]=Math.max(dp[i][j-1],
                    Math.max(dp[i+1][j],dp[i+1][j-1])); //三种情形
                }   
            }
        return dp[1][n];
    }
}
```





## 最长回文子串【中等-自己做的】

注意：`i<j`是不合法的，**就是0**，如果i的下标从1开始，那么下标为0的也是不合法的，`dp[0][j]`和`dp[i][0]`**要么就用不到**，用到了就是0

力扣地址：https://leetcode-cn.com/problems/longest-palindromic-substring/



`dp[i][j]`为以`s[i]`开头，以`s[j]`结尾的回文子串，如果不是`s[i...j]`不是回文子串，则`dp[i][j]=-1`。



```java
class Solution {
    public String longestPalindrome(String s) {
        int n=s.length();
        int[][] dp=new int[n][n];
        for(int i=0;i<n;i++)
            dp[i][i]=1;
        for(int i=0;i<n;i++)
            for(int j=0;j<i;j++){
                dp[i][j]=0;
            }
        
        //注意是倒着遍历，可以画一张表格看看
        for(int i=n-2;i>=0;i--)
            for(int j=i+1;j<n;j++){
                if(s.charAt(i)==s.charAt(j)){
                    if(dp[i+1][j-1]==-1)    dp[i][j]=-1;
                    else dp[i][j]=dp[i+1][j-1]+2;//注意是+2
                }else{
                    dp[i][j]=-1;
                }
            }
        int len=0;
        String res="";
        for(int i=0;i<n;i++)
            for(int j=0;j<n;j++){
                if(dp[i][j]!=-1 && dp[i][j]>len){
                    len=dp[i][j];
                    res=s.substring(i,j+1);
                }
            }
        return res;
    }
}
```



稍微优化一下

```java
class Solution {
    public String longestPalindrome(String s) {
        int n=s.length();
        int[][] dp=new int[n][n];
        for(int i=0;i<n;i++)
            dp[i][i]=1;
        for(int i=0;i<n;i++)
            for(int j=0;j<i;j++){
                dp[i][j]=0;
            }
        
        int len=1;
        String res=s.charAt(0)+"";

        //注意是倒着遍历，可以画一张表格看看
        for(int i=n-2;i>=0;i--)
            for(int j=i+1;j<n;j++){
                if(s.charAt(i)==s.charAt(j)){
                    if(dp[i+1][j-1]==-1)    dp[i][j]=-1;
                    else {
                        dp[i][j]=dp[i+1][j-1]+2;//注意是+2
                        if(dp[i][j]>len){
                            len=dp[i][j];
                            res=s.substring(i,j+1);
                        }
                    }
                }else{
                    dp[i][j]=-1;
                }
            }


        return res;
    }
}
```



或者

```java
class Solution {
    public String longestPalindrome(String s) {

        int n=s.length();
        int[][] dp=new int[n+1][n+1];

        for(int i=1;i<=n;i++){
            dp[i][i]=1;
        }
        int max=1;
        int mi=1,mj=1;
        for(int i=n-1;i>=1;i--)
            for(int j=i+1;j<=n;j++){
                //注意这里：dp[i+1][j-1]!=-1不能写成dp[i+1][j-1]!=0,因为0值有用的
                if(s.charAt(i-1)==s.charAt(j-1) && dp[i+1][j-1]!=-1){
                    dp[i][j]=dp[i+1][j-1]+2;
                    if(dp[i][j]>max) {
                        max=dp[i][j];
                        mi=i;
                        mj=j;
                    }
                }else{
                    dp[i][j]=-1;
                }
            }


        return s.substring(mi-1,mj);
    
    }
}
```



我的思考：

```java
class Solution {
    public String longestPalindrome(String s) {

        int n=s.length();
        int[][] dp=new int[n+1][n+1];
        
        //选择
        // if(s[i]==s[j]){
        //     if(dp[i+1][j-1]!=-1) dp[i][j]=dp[i+1][j-1]+2;
        //     else dp[i][j]=-1;
        // }else{
        //     dp[i][j]=-1
        // }

        int max=1;
        int start=0;

        for(int i=1;i<=n;i++){
            dp[i][i]=1;
        }

        for(int i=n-1;i>=1;i--)
            for(int j=i+1;j<=n;j++){
                if(s.charAt(i-1)==s.charAt(j-1)){
                    if(dp[i+1][j-1]!=-1) dp[i][j]=dp[i+1][j-1]+2;
                    else dp[i][j]=-1;
                }else{
                    dp[i][j]=-1;
                }

                if(dp[i][j]>max){
                    max=dp[i][j];
                    start=i-1;
                }
                
            }
        return s.substring(start,start+max);
    }
}
```





## 最长重复子数组【中等-自己做的】

力扣地址：https://leetcode-cn.com/problems/maximum-length-of-repeated-subarray/

`dp[i][j]`表示`nums1[0...i]`和`nums2[0...j]`中以`nums1[i]`和`nums2[j]`结尾的重复子数组，因此一定会满足`nums1[i]=nums2[j]`，否则`dp[i][j]]=0`

关系：

```java
if(nums1[i-1]==nums2[j-1]){
    dp[i][j]=dp[i-1][j-1]+1;
}else{
    dp[i][j]=0;
}
```

初值：nums[0]表示空数组，不表示nums的第一个值，这样一定要谨记，并且规定空数组和所有的子数组的重复子数组为0。

```java
for(int i=0;i<=m;i++)
    dp[i][0]=0;
for(int j=0;j<=n;j++)
    dp[0][j]=0;
```

解法：

```java
class Solution {
    public int findLength(int[] nums1, int[] nums2) {
        int m=nums1.length,n=nums2.length;
        int[][] dp=new int[m+1][n+1];
        for(int i=0;i<=m;i++)
            dp[i][0]=0;
        for(int j=0;j<=n;j++)
            dp[0][j]=0;

        int len=0;
        for(int i=1;i<=m;i++)
            for(int j=1;j<=n;j++){
                if(nums1[i-1]==nums2[j-1]){
                    dp[i][j]=dp[i-1][j-1]+1;
                    if(dp[i][j]>len) len=dp[i][j];
                }else{
                    dp[i][j]=0;
                }
            }

        return len;
    }
}
```

我的思考：

```java
class Solution {
    public int findLength(int[] nums1, int[] nums2) {

        int m=nums1.length,n=nums2.length;
        int[][] dp=new int[m+1][n+1];

        //选择
        // if(nums1[i]==nums2[j])
        //     dp[i][j]=dp[i-1][j-1]+1;
        // else{
        //     dp[i][j]=0;
        // }

        int res=0;
        for(int i=1;i<=m;i++)
            for(int j=1;j<=n;j++){
                if(nums1[i-1]==nums2[j-1]){
                    dp[i][j]=dp[i-1][j-1]+1;
                }else{
                    dp[i][j]=0;
                }
                res=Math.max(res,dp[i][j]);
            }

        return res;

    }
}
```





##  让字符串成为回文串的最少插入次数

> 力扣地址：https://leetcode-cn.com/problems/minimum-insertion-steps-to-make-a-string-palindrome/



`dp[i][j]`表示让字符串`s[i...j]`成为回文串的最少插入次数

```java
class Solution {
    public int minInsertions(String s) {
        int n=s.length();
        int[][] dp=new int[n][n];

        for(int i=n-2;i>=0;i--)
            for(int j=i+1;j<n;j++){
                if(s.charAt(i)==s.charAt(j)){
                    dp[i][j]=dp[i+1][j-1];
                }else{
                    dp[i][j]=1+Math.min(dp[i][j-1],dp[i+1][j]);
                }
            }

        return dp[0][n-1];
    }
}
```



我的思考：

```java
class Solution {
    public int minInsertions(String s) {

        int n=s.length();
        int[][] dp=new int[n+1][n+1];

        //选择，
        // if(s[i]==s[j]){
        //     dp[i][j]=dp[i+1][j-1];
        // }else{
        //     dp[i][j]=Max(1+dp[i][j-1],1+dp[i+1][j]);
        // }
        
        for(int i=1;i<=n;i++)
            dp[i][i]=0;
        
        for(int i=n-1;i>=1;i--)
            for(int j=i+1;j<=n;j++)
                if(s.charAt(i-1)==s.charAt(j-1)){
                    dp[i][j]=dp[i+1][j-1];
                }else{
                    dp[i][j]=Math.min(dp[i+1][j-1]+2,
                    Math.min(1+dp[i][j-1],1+dp[i+1][j])); //不相等时，三种情形
                }
            
        return dp[1][n];

    }
}
```





## 正则表达式匹配【困难】

力扣地址：https://leetcode-cn.com/problems/zheng-ze-biao-da-shi-pi-pei-lcof/

```java
class Solution {
    public boolean isMatch(String s, String p) {
        return dp(s,p,0,0);
        
    }

    public boolean dp(String s,String p,int i,int j){
        //base;
        int m=s.length(),n=p.length();
        if(j==n){
            if(i==m) return true;
            else return false;
        }

        if(i==m){
            if((n-j)%2==1){
                return false;
            }
            for(int k=j;k+1<n;k=k+2){
                if(p.charAt(k+1)!='*') return false;
            }
            return true;

        }

        //logic
        if(s.charAt(i)==p.charAt(j) || p.charAt(j)=='.'){
            if(j+1<n && p.charAt(j+1)=='*'){//匹配0次或多次
                return dp(s,p,i,j+2) || dp(s,p,i+1,j);
            }else{//匹配一次
                return dp(s,p,i+1,j+1);
            }

        }else{
            if(j+1<n && p.charAt(j+1)=='*'){//匹配0次
                return dp(s,p,i,j+2);
            }else{//false
                return false;
                
            }
        }
        

    }
}
```



保存局部最优解

```java
class Solution {
    public HashMap<String,Boolean> map=new HashMap<>();
    public boolean isMatch(String s, String p) {
        return dp(s,p,0,0);
        
    }

    public boolean dp(String s,String p,int i,int j){

        
        //base;
        int m=s.length(),n=p.length();
        if(j==n){
            if(i==m) return true;
            else return false;
        }

        if(i==m){
            if((n-j)%2==1){
                return false;
            }
            for(int k=j;k+1<n;k=k+2){
                if(p.charAt(k+1)!='*') return false;
            }
            return true;

        }

        String key=i+"_"+j;
        if(map.containsKey(key)) return map.get(key);

        boolean res=false;

        //logic
        if(s.charAt(i)==p.charAt(j) || p.charAt(j)=='.'){
            if(j+1<n && p.charAt(j+1)=='*'){//匹配0次或多次
                res=dp(s,p,i,j+2) || dp(s,p,i+1,j);
            }else{//匹配一次
                res=dp(s,p,i+1,j+1);
            }

        }else{
            if(j+1<n && p.charAt(j+1)=='*'){//匹配0次
                res=dp(s,p,i,j+2);
            }else{//false
                res=false;
                
            }
        }

        map.put(key,res);
        return res;
        

    }
}
```





下面二个注意的点：

注意点1：`j>=p.length()`那里一定要`>=`，因为j可能`+2`

注意点2：`(p.length()-j) % 2 == 1` 这里不能写成`p.length()-j % 2 == 1`，一定要加`()`



```java
class Solution {
    HashMap<String,Boolean> map=new HashMap<>();
    public boolean isMatch(String s, String p) {

        return dp(s,0,p,0);
    }

    //初始：i=0,j=0
    //dp：p[j...]是否可以匹配s[i...]
    public boolean dp(String s,int i,String p,int j){
        
        if(j>=p.length()){ //注意这里，一定>=，因为j可能+2
            if(i==s.length()) return true;
            else return false;
        }

        if(i==s.length()){
            if((p.length()-j) % 2 == 1) //%这里不能写成p.length()-j % 2 == 1，一定要加()
                return false;
            
            for(int k=j;k<p.length()-1;k=k+2){
                if(p.charAt(k+1)!='*') return false;
            }
            return true;
        }

        String key=i+"_"+j;
        if(map.containsKey(key)) return map.get(key);

        boolean res=false;

        if(s.charAt(i)==p.charAt(j) || p.charAt(j)=='.'){
            if(j+1<=p.length()-1 && p.charAt(j+1)=='*'){
                //匹配0次,		匹配大于一次
                res = dp(s,i,p,j+2) || dp(s,i+1,p,j);
                //匹配一次（不用要了）【因为匹配多次和匹配0次就包括一次了】
                //dp(s,i+1,p,j+2);
                
            }else{
                res =  dp(s,i+1,p,j+1);//没有*,匹配一次
            }
        }else{
            if(j+1<=p.length()-1 && p.charAt(j+1)=='*'){
                res =  dp(s,i,p,j+2); //匹配0次
            }else{
                res =  false;
            }
        }
        map.put(key,res);
        return res;
    }
}
```





##  4键按键【651-中等】



```java


import java.util.HashMap;

public class Test9{

	static HashMap<String, Integer> map=new HashMap<String, Integer>();
	public static void main(String[] args) {
		System.out.println(maxA(7));
	}
	
	public static int maxA(int n){
		return dp(n,0,0);
	}
	
	//剩余次数为k时，屏幕上A为nums个，剪切板有copy个， 屏幕上最多有dp个
	public static int dp(int k,int nums,int copy){

		
		if(k<=0) return nums;
		
		
		String key=k+"_"+nums+"_"+copy;
		if(map.containsKey(key)) return map.get(key);
		int res=0;
		res=Math.max(dp(k-1,nums+1,copy), 
				Math.max(dp(k-2,nums,nums), dp(k-1,nums+copy,copy)));
		map.put(key, res);
		return res;
		
	}
	
}

```



另外的dp定义方式：

```java
	public static void main(String[] args) {
		System.out.println(maxA(7));
	}
	
	public static int maxA(int n){
		int[] dp=new int[n+1];//dp表示操作n次后，A最多有dp[n]个
		
		dp[0]=0;
		dp[1]=1;
		for(int i=1;i<=n;i++){
			dp[i]=dp[i-1]+1;//按A
			for(int j=2;j<i;j++){//第i次按C-V
				dp[i]=Math.max(dp[i],dp[j-2]*(i-j+1));
			}
		}
		
		return dp[n];
	}
```



## 高楼扔鸡蛋【困难】

力扣地址：https://leetcode-cn.com/problems/super-egg-drop/submissions/

`dp(k,n)`函数定义：当鸡蛋数为k，总楼层数为n时最坏情况下的**最小操作次数**

**下面执行超时**

```java
class Solution {
    HashMap<String,Integer> map=new HashMap<>();
    public int superEggDrop(int k, int n) {
        
        return dp(k,n);

    }

    public int dp(int k,int n){
        if(k==1) return n;
        if(n==0) return 0;
        String key=k+"_"+n;
        if(map.containsKey(key)) return map.get(key);

        int res=Integer.MAX_VALUE;
        for(int i=1;i<=n;i++){
            res=Math.min(res,Math.max(dp(k,i-1),dp(k-1,n-i))+1);
        }
        map.put(key,res);

        return res;
    }
}
```



**dp法超时**

```java
class Solution {
    public int superEggDrop(int k, int n) {
        if(k==1) return n;
        if(n==1) return 1;

        int[][] dp=new int[k+1][n+1];


        for(int j=0;j<=n;j++){
            dp[1][j]=j;
        }

        for(int i=2;i<=k;i++)
            for(int j=1;j<=n;j++){
                int res=Integer.MAX_VALUE;
                for(int m=1;m<=j;m++)
                    res=Math.min(res,Math.max(1+dp[i-1][m-1],1+dp[i][j-m]));
                dp[i][j]=res;
            }

        return dp[k][n];
        
    }
}
```





换一种定义方式：

k个鸡蛋时，共扔m次，确定n层楼，`dp[k][m]=n`

状态转移方程`dp[k][m]=dp[k][m-1]+dp[k-1][m-1]+1;` 

- 鸡蛋不碎时仍为k个鸡蛋，扔的次数少了1，确定楼层的楼层`dp[k][m-1]`（向上）
- 鸡蛋碎时为k-1个鸡蛋，扔的次数少了1，确定楼层的楼层`dp[k-1][m-1]`（向下）
- 加上当前的一层楼，状态转移方程`dp[k][m]=dp[k][m-1]+dp[k-1][m-1]+1;` 

```java
class Solution {
    HashMap<String,Integer> map=new HashMap<>();
    public int superEggDrop(int k, int n) {
        
        return dp(k,n);

    }

    public int dp(int k,int n){
        
        //k个鸡蛋时，仍m次，确定n层楼，dp[k][m]=n
        int[][] dp=new int[k+1][n+1];

        int m=0;
        while(dp[k][m]<n){
            m++;
            for(int i=1;i<=k;i++){
                dp[i][m]=dp[i][m-1]+dp[i-1][m-1]+1;
            }
        }

        return m;
    }
}
```



我的选择

```java
class Solution {
    HashMap<String,Integer> map=new HashMap<>();
    public int superEggDrop(int k, int n) {
        int m=n+1;
        int[][] dp=new int[k+1][m+1]; //共k个接单，共仍了m次，确定n层楼

        //选择
        //dp[i][j]=dp[i-1][j-1]+dp[i][j-1]+1;

        int j=0;

        while(dp[k][j]<n){ //一定要小于n，因为这样跳出循环的结果才等于n
            j++;
            for(int i=1;i<=k;i++){
                dp[i][j]=dp[i-1][j-1]+dp[i][j-1]+1;
            }
        }

        return j;


    }

}
```





## 戳气球【困难】

> 力扣地址：https://leetcode-cn.com/problems/burst-balloons/

方法一：回溯法【超时】

```java
class Solution {
    int result=Integer.MIN_VALUE;
    public int maxCoins(int[] nums) {
        ArrayList<Integer> list=new ArrayList<Integer>();
        for(int n:nums){
            list.add(n);
        }
        process(list,0);
        return result;
    }

    public void process(ArrayList<Integer> nums,int pre){

        if(nums.size()==0){
            result=Math.max(pre,result);
        }
        
        int size=nums.size();
        int temp;
        for(int i=0;i<size;i++){
            temp=nums.get(i);
            int res=0,left=1,right=1;
            if(i-1>=0) left=nums.get(i-1);
            if(i+1<=size-1) right=nums.get(i+1);
            res=pre+left*nums.get(i)*right;

            nums.remove(i);
            process(nums,res);
            nums.add(i,temp);
        }
    }
}
```

方法二：动态规划

`dp[i][j]`表示i和j之间（开区间）戳破所有气球的最高分数。

如果k是最后一个被戳破的气球，则

```java
dp[i][j]=Math.max(dp[i][j],dp[i][k]+dp[k][j]+points[i]*points[k]*points[j]);
```

解法如下：

```java
class Solution {
    int result=Integer.MIN_VALUE;
    public int maxCoins(int[] nums) {
        int n=nums.length;
        int[] points=new int[n+2];
        points[0]=points[n+1]=1;
        for(int i=1;i<=n;i++)
            points[i]=nums[i-1];

        int[][] dp=new int[n+2][n+2];
        
        for(int i=n+1;i>=0;i--)
            for(int j=0;j<=n+1;j++){
                for(int k=i+1;k<j;k++){
                    dp[i][j]=Math.max(dp[i][j],dp[i][k]+dp[k][j]+points[i]*points[k]*points[j]);
                }
            }
        
        return dp[0][n+1];
    }

}
```

我的思考：

```java
class Solution {
    public int maxCoins(int[] nums) {
        int n=nums.length;
        int[] points=new int[n+2];
        points[0]=points[n+1]=1;

        for(int i=0;i<n;i++){
            points[i+1]=nums[i];
        }
        int len=n+2;
        int[][] dp=new int[len][len];//表示(i,j)【开区间】的最大分数
        
        //选择
        // points[i],points[j]
        // dp[i][j],
        // i<k<j, 剩下k
        // dp[i][k]+dp[k][j]+points[i]*points[k]*points[j]

        //base
        // i==j,0
        // i+1==j,0
        // i>j,0
        for(int i=len-2;i>=0;i--)
            for(int j=i+2;j<len;j++){
                for(int k=i+1;k<j;k++){
                    dp[i][j]=Math.max(dp[i][j],
                    dp[i][k]+dp[k][j]+points[i]*points[k]*points[j]);
                }
            }

        return dp[0][len-1];
    }
}
```





## 0-1背包问题

**dp函数**：



```java
public class Main {

	static int N=3;
	static int W=4;
	static int[] wt={2,1,3};
	static int[] val={4,2,3};
	public static void main(String[] args) {
		System.out.println(dp(N-1,W));
	}

	//dp：[0..i]中 背包容量为w的最大价值
	public static int dp(int i,int w){
		if(w==0) return 0;
		
		if(i<0){ //不用判断==0，只用判断边界就行啦啦啦，不用自己找麻烦
			return 0;
		}
		
		int res1=0,res2=0;
		if(w-wt[i]<0){//不选择  ，注意这里只能不选择
			res1=dp(i-1,w);
		}else{
			res1=dp(i-1,w); //不选择
			res2=val[i]+dp(i-1,w-wt[i]);//选择
		}

		//选择，不选择
		int res=Math.max(res1,res2);
		return res;
	}
}

```

**dp数组：**

```java
import java.util.HashMap;
import java.util.Hashtable;
import java.util.Iterator;
import java.util.Map;
import java.util.TreeMap;



public class Main {
	static int N=3;
	static int W=4;
	static int[] wt={2,1,3};
	static int[] val={4,2,3};
	public static void main(String[] args) {
		int[][] dp=new int[N+1][W+1];
		
		for(int i=1;i<=N;i++)
			for(int j=1;j<=W;j++){
				if(j-wt[i-1]<0) dp[i][j]=dp[i-1][j];//注意这里只能不选择
				else dp[i][j]=Math.max(val[i-1]+dp[i-1][j-wt[i-1]],dp[i-1][j]);
			}
		System.out.println(dp[N][W]);

	}

}

```





## 分割等和子集【中等】

力扣地址：https://leetcode-cn.com/problems/partition-equal-subset-sum/

`dp[i][j]=true`表示在`nums[1...i]`中存在子集的和能够恰好装满重量为j的背包中

`dp[i][j]=false`表示在`nums[1...i]`中不存在子集的和能够恰好装满重量为j的背包中

> nums中的元素可以理解为重量

```java
class Solution {
    public boolean canPartition(int[] nums) {
        int sum=0;
        for(int t:nums)
            sum+=t;

        if(sum%2!=0) return false;
        
        sum=sum/2;
        int n=nums.length;
        boolean[][] dp=new boolean[n+1][sum+1];

        for(int i=0;i<=n;i++)
            dp[i][0]=true;

        for(int i=1;i<=n;i++)
            for(int j=1;j<=sum;j++){
                if(j-nums[i-1]<0) dp[i][j]=dp[i-1][j]; //注意这里
                else dp[i][j]=dp[i-1][j-nums[i-1]]||dp[i-1][j];
            }

        return dp[n][sum];
    }
}
```

dp函数：

```scala
class Solution {
    HashMap<String,Boolean> map=new HashMap<>();
    public boolean canPartition(int[] nums) {
        int sum=0;
        for(int t:nums) sum+=t;

        if(sum%2!=0) return false;

        sum=sum/2;
       //return dp(nums.length-1,sum,nums);
        int n=nums.length;
        boolean[][] dp=new boolean[n+1][sum+1];
        
        for(int i=0;i<=n;i++){
            dp[i][0]=true;
        }

        for(int i=1;i<=n;i++)
            for(int j=1;j<=sum;j++){
                if(j-nums[i-1]<0) dp[i][j]=dp[i-1][j];
                else dp[i][j]=dp[i-1][j-nums[i-1]] || dp[i-1][j];
            }

        return dp[n][sum];

    }
    public boolean dp(int i,int w,int[] nums){//超时，但正确
        if(w==0){
            return true;
        }
        if(i<0){
            return false;
        }

        String key=i+"_"+w;
        if(map.containsKey(key)) return map.get(key);
        
        boolean res1=false,res2=false;
        if(w-nums[i]<0){//不选择
            res1=dp(i-1,w,nums);
        }else{//不选择，选择
            res1=dp(i-1,w,nums);
            res2=dp(i-1,w-nums[i],nums);
        }
        boolean res= res1 || res2;
        map.put(key,res);
        return res;
    }
}
```



## 零钱兑换（二）【中等】

力扣地址：https://leetcode-cn.com/problems/coin-change-2/

`dp[i][j]`表示只用`coins[1...i]`凑成总金额为j的方式数。



```java
class Solution {
    public int change(int amount, int[] coins) {
        
        int n=coins.length;
        int[][] dp=new int[n+1][amount+1];
        for(int i=0;i<=n;i++)
            dp[i][0]=1;
        
        for(int i=1;i<=n;i++)
            for(int j=1;j<=amount;j++){
                if(j-coins[i-1]<0) dp[i][j]=dp[i-1][j];//注意这里
                else dp[i][j]=dp[i-1][j]+dp[i][j-coins[i-1]];  //即便选择了，因为硬币有无数个，所以还是从i开始
            }

        return dp[n][amount];
    }
}
```

dp函数：

```java
class Solution {
    HashMap<String,Integer> map=new HashMap<>();
    public int change(int amount, int[] coins) {
        return dp(coins.length-1,amount,coins);
    }

    public int dp(int i,int target,int[] coins){

        if(target==0){
            return 1;
        }

        if(i<0){
            return 0;
        }

        String key=i+"_"+target;
        if(map.containsKey(key)) return map.get(key);

        int res1=0,res2=0;

        if(target-coins[i]<0){//只能不选择了
            res1=dp(i-1,target,coins);
        }else{
            res1=dp(i-1,target,coins);//不选择
            res2=dp(i,target-coins[i],coins);//选择，因为硬币有无数个，所以还是从i开始
        }
        map.put(key,res1+res2);
        return res1+res2;
    }
}
```





## 打家劫舍【中等】

力扣地址：https://leetcode-cn.com/problems/house-robber/

**方法一:**

`dp[i]`表示在`nums[1...i]`中以`nums[i]`结尾的最高金额。

```java
class Solution {
    public int rob(int[] nums) {

        int n=nums.length;
        int[] dp=new int[n+1];
        for(int i=1;i<=n;i++)
            dp[i]=nums[i-1];

        for(int i=1;i<=n;i++)
            for(int j=0;j<i-1;j++){
                dp[i]=Math.max(dp[i],dp[j]+nums[i-1]);
            }

        int max=Integer.MIN_VALUE;
        for(int t:dp)
            max=Math.max(t,max);
        return max;
    }
}
```



**方法二：**

`dp(int[] nums,int i)`表示`nums[i...]`中的最高金额。

dp函数：自下而上

```java
class Solution {
    int[] memo;
    public int rob(int[] nums) {
        memo=new int[nums.length];
        Arrays.fill(memo,-1);
        return dp(nums,0);
    }

    public int dp(int[] nums,int i){

        if(i>=nums.length) return 0;
        if(memo[i]!=-1) return memo[i];

        int res=Integer.MIN_VALUE;
        res=Math.max(res,Math.max(nums[i]+dp(nums,i+2),
            dp(nums,i+1)));
        memo[i]=res;
        return res;
    }
}
```

转化为dp数组（那就是自上而下了）

```java
class Solution {

    public int rob(int[] nums) {
        int n=nums.length;
        int[] dp=new int[n+2];
        for(int i=n-1;i>=0;i--)
            dp[i]=Math.max(dp[i+1],nums[i]+dp[i+2]);

        return dp[0];
    }


}
```



## 打家劫舍2【中等】

力扣地址：https://leetcode-cn.com/problems/house-robber-ii/





```java
class Solution {
    public int rob(int[] nums) {
        if(nums.length==1) return nums[0];
        int n=nums.length;
        return Math.max(dp(nums,0,n-2),dp(nums,1,n-1));
    }

    
    public int dp(int[] nums,int s,int e){
        int n=nums.length;
        int[] dp=new int[n+2];
        for(int i=e;i>=s;i--)
            dp[i]=Math.max(dp[i+1],nums[i]+dp[i+2]);

        return dp[s];
    }
}
```



## 打家劫舍3【中等】

力扣地址：https://leetcode-cn.com/problems/house-robber-iii/



```java
class Solution {
    HashMap<TreeNode,Integer> map=new HashMap<>();
    public int rob(TreeNode root) {
        return process(root);
    }

    public int process(TreeNode root){
        if(root==null) return 0;
        if(map.containsKey(root)) return map.get(root);

        //拿了
        int solu1=root.val+(root.left==null?0:(process(root.left.left)+process(root.left.right)))+(root.right==null?0:(process(root.right.left)+process(root.right.right)));

        //没na
        int solu2=process(root.left)+process(root.right);

        int res=Math.max(solu1,solu2);
        map.put(root,res);
        return res;
    }
}
```

我的思考：

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    HashMap<TreeNode,Integer> map=new HashMap<>();
    public int rob(TreeNode root) {
        if(root==null) return 0;
        if(root.left==null && root.right==null){
            return root.val;
        }
        if(map.containsKey(root)) return map.get(root);

        //拿root
        int res1=root.val;
        if(root.left!=null){
            res1+=rob(root.left.left);
            res1+=rob(root.left.right);
        }
        if(root.right!=null){
            res1+=rob(root.right.left);
            res1+=rob(root.right.right);
        }
        int res2=0;//不拿root
        if(root.left!=null){
            res2+=rob(root.left);
        }
        if(root.right!=null){
            res2+=rob(root.right);
        }
        int res=Math.max(res1,res2);
        map.put(root,res);
        return res;
    }
}
```





## 目标和

力扣地址：https://leetcode-cn.com/problems/target-sum/





```java
class Solution {
    HashMap<String,Integer> map=new HashMap<>();
    public int findTargetSumWays(int[] nums, int target) {
        return dp(nums,target,0);
    }

    //i从0开始
    //dp函数表示nums[i...]中表达式为target的数目
    public int dp(int[] nums, int target,int i){
        
        if(i>=nums.length){//选完了
            if(target==0) return 1;
            else return -1;
        }

        String key=target+"_"+i;
        if(map.containsKey(key)) return map.get(key);

        int res=0;
        //只能选择nums[i]
        int r1=dp(nums,target+nums[i],i+1),r2=dp(nums,target-nums[i],i+1);
        if(r1!=-1){
            res+=r1;
        }
        if(r2!=-1){
            res+=r2;
        }
        map.put(key,res);
        return res;
        
    }
}
```

我的思考：

<font color="red" size="7">注意：0的时候是有两种的,+0，-0是两个表达式</font>

```java
class Solution {
    HashMap<String,Integer> map=new HashMap<>();
    public int findTargetSumWays(int[] nums, int target) {
        int n=nums.length;

        int res=dp(nums,n-1,target);
        return res==-1?0:res;
    }
    //dp表示：num[0...i]中达成target的数目
    //初始i=len-1,aim=target
    public int dp(int[] nums,int i,int aim){


        if(i==0){
            if(nums[0]==aim && nums[0]==-aim) return 2; //注意：0的时候是有两种的,+0，-0是两个表达式
            else if(nums[0]==aim || nums[0]==-aim) return 1;
            else return -1;
        }

        String key=i+"_"+aim;
        if(map.containsKey(key)) return map.get(key);

        int r1=dp(nums,i-1,aim-nums[i]);
        int r2=dp(nums,i-1,aim+nums[i]);
        

        int res=0;
        if(r1==-1 || r2==-1){
            if(r1==-1 && r2==-1) res = -1;
            else res = r1==-1?r2:r1;
        }else{
            res = r1+r2;
        }

        map.put(key,res);
        return res;

    }
}
```







## 补充



### [121. 买卖股票的最佳时机](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock/)

https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock/



```java
class Solution {
    public int maxProfit(int[] prices) {

        int n=prices.length;
        int[] dp=new int[n];//以[i..]开头的最大利润
        //prices[i]
        //dp[i],dp[i-1]
            // for(int k=n-1;k>i;k--) //这样会超时
            //     if(prices[i]<prices[k])
            //         dp[i]=Math.max(dp[i],dp[k]+prices[k]-prices[i]);

        //base
        dp[n-1]=0;
        int res=0;
        int rightMax=prices[n-1];
        for(int i=n-2;i>=0;i--){
            if(prices[i]<rightMax){ //只记录右边的最大值即可
                dp[i]=rightMax-prices[i];
            }else{
                rightMax=prices[i];
            }
            res=Math.max(res,dp[i]);
        }
        return res;            
    }
}
```





推荐解法：

https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-iii/solution/zui-jian-dan-2-ge-bian-liang-jie-jue-suo-71fe/

```tex
class Solution {
    public int maxProfit(int[] prices) {

        int buy=Integer.MIN_VALUE,sell=0;
        for(int price:prices){
            buy=Math.max(buy,-price);
            sell=Math.max(sell,buy+price);
        }
        return sell;
    }
}
```





### [122. 买卖股票的最佳时机 II](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-ii/)

https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-ii/

这道题的巧妙解法，虽然相邻的不能同时买卖，但是下面的计算方式永远都是最大值

```java
class Solution {
    public int maxProfit(int[] prices) {
        int n=prices.length;

        int res=0;
        int rightMax=prices[n-1];

        for(int i=n-2;i>=0;i--)
            if(prices[i]<prices[i+1]){
                res+=prices[i+1]-prices[i]; //后面的减去前面相邻的
            }
        return res;
    }
}
```

推荐解法：

https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-iii/solution/zui-jian-dan-2-ge-bian-liang-jie-jue-suo-71fe/

```java
class Solution {
    public int maxProfit(int[] prices) {
        int buy=Integer.MIN_VALUE,sell=0;
        for(int price:prices){
            buy=Math.max(buy,sell-price); //这里已经把上一次卖的给记录了
            sell=Math.max(sell,buy+price);
        }
        return sell;
    }
}
```

下面的你也可以自己记录（不要自找麻烦了）

```java
class Solution {
    public int maxProfit(int[] prices) {
        int buy=Integer.MIN_VALUE,sell=0;
        for(int price:prices){
            int buynow=Math.max(buy,sell-price);
            int sellnow=Math.max(sell,buynow+price);
            buy=buynow;
            sell=sellnow;
        }
        return sell;
    }
}
```





### [123. 买卖股票的最佳时机 III](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-iii/)

https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-iii/



```java
class Solution {
    public int maxProfit(int[] prices) {
        int firstBuy=Integer.MIN_VALUE,firstSell=0;
        int secBuy=Integer.MIN_VALUE,secSell=0;
        
        for(int p:prices){
            firstBuy=Math.max(firstBuy,-p);
            firstSell=Math.max(firstSell,firstBuy+p);
            secBuy=Math.max(secBuy,firstSell-p);
            secSell=Math.max(secSell,secBuy+p);
        }
        return secSell;
    }
}
```



### [188. 买卖股票的最佳时机 IV](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-iv/)

https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-iv/



```java
class Solution {
    public int maxProfit(int k, int[] prices) {
        if(k<=0) return 0;
        int[] buy=new int[k];
        Arrays.fill(buy,Integer.MIN_VALUE);
        int[] sell=new int[k];
        for(int p:prices){
            for(int i=0;i<k;i++){
                if(i-1<0) buy[i]=Math.max(buy[i],-p);
                else buy[i]=Math.max(buy[i],sell[i-1]-p);
                sell[i]=Math.max(sell[i],buy[i]+p);
            }
        }
        return sell[k-1];
    }
}
```





### [714. 买卖股票的最佳时机含手续费](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/)

https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/



```java
class Solution {
    public int maxProfit(int[] prices, int fee) {
        int buy=Integer.MIN_VALUE,sell=0;
        for(int p:prices){
            buy=Math.max(buy,sell-p-fee);
            sell=Math.max(sell,buy+p);
        }
        return sell;
    }
}
```



### [309. 最佳买卖股票时机含冷冻期](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-with-cooldown/)

这个先不看了

