动态规划适用于计算**满足某种条件的序列或子串的个数**，不适用于计算满足某种条件的具体的序列或子串。当然每次把结果记录下来也是可以的。【但是这样可能有时对于不连续的序列，不太好做】

动态规划的一个技巧可以试一试，就是如果没有想到定义dp数组或者dp函数的时候，直接让输入的值等于结果，这样试试能不能做出来，比如输入3,4，输出6，dp定义为`dp[3][4]=6`，然后反推状态和dp数组的定义。就算这样不行，和这个也大差不差，估计稍微改一下就行。

**唯一原理：数学规划法**

**dp等于的结果数**=**选择的结果数**

我是不是可以首先考虑递归函数？这样的话循环几乎就不用考虑，边界也容易考虑，只用把中心放在业务逻辑上就行。甚至只根据选择就能做出来？

很得意情况下，dp函数更简单一点吧。dp函数设计的基本：**先考虑base，然后做选择越来越接近base**。 dp函数几乎都是自上而下，当然也有自下而上的dp函数。

**先考虑base，然后做选择越来越接近base**



base一般只有一行或者一列有，很少有第二行有的

> dp函数边界尽量考虑异常情况啊

# 递归和动态规划

##  换钱的最少货币数

牛客地址：https://www.nowcoder.com/practice/4e05294fc5aa4d4fa8eacef2e606e5a8?tpId=101&&tqId=33080&rp=1&ru=/ta/programmer-code-interview-guide&qru=/ta/programmer-code-interview-guide/question-ranking

解析：labuladong 1.2节



函数`dp(int aim,int[] coins)`或数组`dp[aim]`代表目标为aim的最少货币数



方法一：dp函数自上而下暴力求解

```java

import java.util.Scanner;

public class Main{
    
    public static void main(String[] args){
        Scanner sc=new Scanner(System.in);
        int n=sc.nextInt(),aim=sc.nextInt();
        int[] coins=new int[n];
        for(int i=0;i<n;i++)
            coins[i]=sc.nextInt();
        System.out.print(dp(aim,coins));
    }
    
    public static int dp(int aim,int[] coins){
        if(aim<0) return -1;
        if(aim==0) return 0;
        
        int res=Integer.MAX_VALUE;
        int solu=0;
        for(int c:coins){
            solu=dp(aim-c,coins);
            if(solu==-1) continue;
            res=Math.min(res,1+solu);
        }
        
        return res==Integer.MAX_VALUE?-1:res;
        
    }
}
```







方法二：dp函数自上而下-保存局部最优解

```java

import java.util.Scanner;
import java.util.HashMap;

public class Main{
    static HashMap<Integer,Integer> map=new HashMap<>();
    public static void main(String[] args){
        Scanner sc=new Scanner(System.in);
        int n=sc.nextInt(),aim=sc.nextInt();
        int[] coins=new int[n];
        for(int i=0;i<n;i++)
            coins[i]=sc.nextInt();
        System.out.print(dp(aim,coins));
    }
    
    public static int dp(int aim,int[] coins){
        if(aim<0) return -1;
        if(aim==0) return 0;
        
        int res=Integer.MAX_VALUE;
        int solu=0;
        for(int c:coins){
            if(map.get(aim)!=null){
                return map.get(aim);
            }
            solu=dp(aim-c,coins);
            if(solu==-1) continue;
            res=Math.min(res,1+solu);
        }
        res=res==Integer.MAX_VALUE?-1:res;
        map.put(aim,res);
        return res;
        
    }
}
```





方法三：dp数组自下而上

```java

import java.util.Scanner;
import java.util.HashMap;

public class Main{
    static HashMap<Integer,Integer> map=new HashMap<>();
    public static void main(String[] args){
        Scanner sc=new Scanner(System.in);
        int n=sc.nextInt(),aim=sc.nextInt();
        int[] coins=new int[n];
        for(int i=0;i<n;i++)
            coins[i]=sc.nextInt();
        System.out.print(func(aim,coins));
    }
    
    public static int func(int aim,int[] coins){
        int[] dp=new int[aim+1];
        for(int i=0;i<dp.length;i++){
            dp[i]=aim+1;
        }
        dp[0]=0;
        
        for(int i=1;i<dp.length;i++)
            for(int c:coins){
                if(i-c<0) continue;
                dp[i]=Math.min(dp[i],1+dp[i-c]);
            }
        return dp[aim]==aim+1?-1:dp[aim];
    }
}
```



### 另外一种思路

dp函数：

```java

import java.util.Scanner;
import java.util.HashMap;

public class Main{
    static HashMap<String,Integer> map=new HashMap<>();
    public static void main(String[] args){
        Scanner sc=new Scanner(System.in);
        int n=sc.nextInt(),aim=sc.nextInt();
        int[] coins=new int[n];
        for(int i=0;i<n;i++)
            coins[i]=sc.nextInt();
         System.out.print(dp(n-1,aim,coins));
    }
    
    //dp：表示选择coins[0...i]中的任意硬币组成aim的最少硬币数
    public static int dp(int i,int aim,int[] coins){ //超时，但正确
        
        if(aim==0){
            return 0;
        }
        
        if(i<0) return -1;
        
        String key=i+"_"+aim;
        if(map.containsKey(key)) return map.get(key);
        
        int res1=-1,res2=-1; //-1代表这种方案不行
        if(aim-coins[i]<0){//不选择
            res1=dp(i-1,aim,coins);
        }else{
            res1=dp(i-1,aim,coins);//不选择
            res2=dp(i,aim-coins[i],coins);//选择，注意硬币有任意个
            if(res2!=-1) res2=1+res2;//选择的时候要判断以前的方案是否可行，如果不可行，选择了也没用
        }
        
        
        int res=0;
        if(res1!=-1 && res2!=-1){
            res=Math.min(res1,res2);
        }else {
            res=res1==-1?res2:res1;
        }
        map.put(key,res);
        return res;
        
    }
}
```

dp数组：

```java

import java.util.Scanner;
import java.util.HashMap;

public class Main{
    static HashMap<String,Integer> map=new HashMap<>();
    public static void main(String[] args){
        Scanner sc=new Scanner(System.in);
        int n=sc.nextInt(),aim=sc.nextInt();
        int[] coins=new int[n];
        for(int i=0;i<n;i++)
            coins[i]=sc.nextInt();
        
        int[][] dp=new int[n+1][aim+1];
        for(int w=1;w<=aim;w++){
            dp[0][w]=-1;
        }
        
        for(int i=1;i<=n;i++)
            for(int j=1;j<=aim;j++){
                int res1=-1,res2=-1;
                if(j-coins[i-1]<0){//不选择
                    res1=dp[i-1][j];
                }else{
                    res1=dp[i-1][j];//不选择
                    res2=dp[i][j-coins[i-1]];//选择
                    if(res2!=-1) res2=1+res2;
                }
                int res=0;
                if(res1!=-1 && res2!=-1){
                    res=Math.min(res1,res2);
                }else {
                    res=res1==-1?res2:res1;
                }
                dp[i][j]=res;
                
            }
        System.out.println(dp[n][aim]);
        
    }
}
```

**历史遗留错误**：（尽量不要看）

错误一：边界考虑的情况，**一般dp只用第一行和第一列有base，哪有第二行有的**。所以dp函数只用考虑`i<0`。并且就是dp函数里把`i==0`的情况写了，很容易很容易出错，你看dp数组下不就错了嘛

错误二：dp函数没有判断`if(aim-coins[i])<0`，这本来就是错误的嘛

```java

import java.util.Scanner;
import java.util.HashMap;

public class Main{
    static HashMap<String,Integer> map=new HashMap<>();
    public static void main(String[] args){
        Scanner sc=new Scanner(System.in);
        int n=sc.nextInt(),aim=sc.nextInt();
        int[] coins=new int[n];
        for(int i=0;i<n;i++)
            coins[i]=sc.nextInt();
        
        int[][] dp=new int[n+1][aim+1];
        for(int w=1;w<=aim;w++){
            dp[0][w]=-1;
//             if(aim%coins[0]==0) dp[1][w]=aim/coins[0]; //这个一用就错了
//             else dp[1][w]=-1;
        }
        
        for(int i=1;i<=n;i++)
            for(int j=1;j<=aim;j++){
                int res1=-1,res2=-1;
                if(j-coins[i-1]<0){//不选择
                    res2=dp[i-1][j];
                }else{
                    if(dp[i][j-coins[i-1]]==-1) res1=-1;
                    else res1=1+dp[i][j-coins[i-1]];//选择
                    res2=dp[i-1][j];//不选择
                }
                int res=0;
                if(res1!=-1 && res2!=-1){
                    res=Math.min(res1,res2);
                }else {
                    res=res1==-1?res2:res1;
                }
                dp[i][j]=res;
                
            }
        System.out.println(dp[n][aim]);
        
        
//         System.out.print(dp(n-1,aim,coins));
    }
    
    public static int dp(int i,int aim,int[] coins){
        
        if(i==0){ 
            if(aim%coins[0]==0) return aim/coins[0];
            else return -1;
        }
        
        if(aim==0) return 0;
        
        if(aim<0) return -1;
        
        String key=i+"_"+aim;
        if(map.containsKey(key)) return map.get(key);
        //选择
        int res1=dp(i,aim-coins[i],coins);
        if(res1!=-1) res1=1+res1;
        
        //不选择
        int res2=dp(i-1,aim,coins);
        
        int res=0;
        if(res1!=-1 && res2!=-1){
            res=Math.min(res1,res2);
        }else {
            res=res1==-1?res2:res1;
        }
        map.put(key,res);
        return res;
        
    }
}
```





## 最长递增子序列

力扣地址：https://leetcode-cn.com/problems/longest-increasing-subsequence/



函数`dp(int[] nums,int index)`代表以nums[index]结尾的最长递增子序列

如果`dp(int[] nums,int index)`代表nums[0...index]数组的最长递增子序列，则这道题做不出来。一定要定义一个可以用数学归纳法做出来的函数或数组。

数学归纳法：labuladong 2.1 P97



方法一：dp函数-暴力解法

```java
class Solution {

    public int lengthOfLIS(int[] nums) {
        int[] result=new int[nums.length];

        for(int i=0;i<nums.length;i++){
            result[i]=dp(nums,i);
        }

        int max=0;
        for(int r:result)
            max=Math.max(max,r);

        return max;

    }

    // dp(int[] nums,int index)代表以index结尾的最长递增子序列的个数
    public int dp(int[] nums,int index){
        if(index==0) return 1;

        int res=Integer.MIN_VALUE;
        for(int i=0;i<=index-1;i++){
            if(nums[i]<nums[index]){
                res=Math.max(res,dp(nums,i)+1);
            }
        }

        return res==Integer.MIN_VALUE?1:res;

    }
}
```



方法二：dp函数自上而下-保存局部最优解

```java
class Solution {

    public int[] result;
    public int lengthOfLIS(int[] nums) {
        result=new int[nums.length];
        result[0]=1;

        for(int i=0;i<nums.length;i++){
            if(result[i]==0)//注意，只执行dp(nums,nums.length-1)不一定会让每个result都有值，因为dp中有判断大小那一步
                result[i]=dp(nums,i);
        }
        int max=0;
        for(int r:result)
            max=Math.max(max,r);

        return max;

    }

    public int dp(int[] nums,int index){
        if(index==0) return 1;

        int res=Integer.MIN_VALUE;
        int solu;
        for(int i=0;i<=index-1;i++){
            if(nums[i]<nums[index]){
                if(result[i]!=0) solu=result[i];
                else solu=dp(nums,i);
                res=Math.max(res,solu+1);
            }
        }

        res=res==Integer.MIN_VALUE?1:res;

        result[index]=res;
        
        return res;

    }
}
```



方法三：dp数组自下而上

```java
class Solution {

    public int lengthOfLIS(int[] nums) {

        int max=0;
        int[] result=func(nums);
        for(int r:result)
            max=Math.max(max,r);

        return max;

    }

    public int[] func(int[] nums){
        int[] dp=new int[nums.length];
        dp[0]=1;

        int max;
        for(int i=1;i<dp.length;i++){
            max=Integer.MIN_VALUE;
            for(int j=0;j<=i-1;j++){
                if(nums[j]<nums[i]){
                    max=Math.max(max,dp[j]+1);
                }
                dp[i]=max==Integer.MIN_VALUE?1:max;
            }
        }

        return dp;
    }
}
```



方法三：简洁化

```java
class Solution {

    public int lengthOfLIS(int[] nums) {

        int max=0;
        int[] result=func(nums);
        for(int r:result)
            max=Math.max(max,r);

        return max;

    }

    public int[] func(int[] nums){
        int[] dp=new int[nums.length];
        Arrays.fill(dp,1);
        
        int max;
        for(int i=1;i<dp.length;i++){
            max=Integer.MIN_VALUE;
            for(int j=0;j<=i-1;j++){
                if(nums[j]<nums[i]){
                	dp[i]=Math.max(dp[i],dp[j]+1);
                }
            }
        }

        return dp;
    }
}
```





## 俄罗斯套娃信封问题【困难】

地址：[力扣 (leetcode-cn.com)](https://leetcode-cn.com/problems/russian-doll-envelopes/)

labuladong：2.2

先按第一个值升序，第一个值相等时再按照第二个值降序，转化成一个最长递增子序列问题

```java
import java.util.Arrays;

class Solution {
    public int maxEnvelopes(int[][] envelopes) {

        Arrays.sort(envelopes,new Comparator<int[]>(){
            public int compare(int[] a1,int[] a2){
                return a1[0]==a2[0]?a2[1]-a1[1]:a1[0]-a2[0];
            }
        });
        
        int[] height=new int[envelopes.length];
        for(int i=0;i<envelopes.length;i++){
            height[i]=envelopes[i][1];
        }
        return getMaxSub(height);

    }

    public int getMaxSub(int[] nums){
        int[] result=new int[nums.length];
        result[0]=1;
        
        for(int i=1;i<nums.length;i++){
            if(result[i]==0) dp(nums,i,result);
        }
        
        int max=0;
        for(int a:result)
            max=Math.max(max,a);
        return max;
    }

    public int dp(int[] nums,int index,int[] result){
        if(index==0) return 1;

        int res=1;
        for(int i=0;i<=index-1;i++){
            if(nums[i]<nums[index]){
                if(result[i]==0)
                    res=Math.max(res,1+dp(nums,i,result));
                else res=Math.max(res,1+result[i]);
            }
        }
        result[index]=res;
        return res;
    }
}
```



当然也可以用dp数组

```java
import java.util.Arrays;

class Solution {
    public int maxEnvelopes(int[][] envelopes) {

        Arrays.sort(envelopes,new Comparator<int[]>(){
            public int compare(int[] a1,int[] a2){
                return a1[0]==a2[0]?a2[1]-a1[1]:a1[0]-a2[0];
            }
        });
        
        int[] height=new int[envelopes.length];
        for(int i=0;i<envelopes.length;i++){
            height[i]=envelopes[i][1];
        }
        return dp(height);

    }

    public int dp(int[] nums){
        int[] result=new int[nums.length];
        Arrays.fill(result,1);
        for(int i=1;i<result.length;i++){
            for(int j=0;j<=i-1;j++){
                if(nums[j]<nums[i])
                    result[i]=Math.max(result[i],1+result[j]);
            }
        }

        int max=0;
        for(int a:result)
            max=Math.max(max,a);

        return max;
    }
}
```



## 最大子序和【简单】

地址：[53. 最大子序和 - 力扣（LeetCode） (leetcode-cn.com)](https://leetcode-cn.com/problems/maximum-subarray/)



dp[i]表示以i结尾的最大连续子序和

想一下数学归纳法，就可以解题了。





```java
class Solution {
    public int maxSubArray(int[] nums) {
        return dp(nums);
    }

    public int dp(int[] nums){
        int[] dp=new int[nums.length];
        for(int i=0;i<nums.length;i++){
            dp[i]=nums[i];
        }

        for(int i=1;i<nums.length;i++){
            dp[i]=Math.max(dp[i],nums[i]+dp[i-1]);
        }
        
        int max=Integer.MIN_VALUE;
        for(int a:dp)
            max=Math.max(max,a);

        return max;
    }
}
```



## 最长公共子序列【中等】



力扣地址：https://leetcode-cn.com/problems/longest-common-subsequence/submissions/



### 方法一：dp函数自上而下-暴力破解

```java
class Solution {
    public int longestCommonSubsequence(String text1, String text2) {
        return dp(text1,text2,text1.length()-1,text2.length()-1);
    }

    public int dp(String s1,String s2,int i,int j){
        if(i==-1) return 0;
        if(j==-1) return 0;
        
        if(s1.charAt(i)==s2.charAt(j)){
            return 1+dp(s1,s2,i-1,j-1);
        }else{
            return Math.max(dp(s1,s2,i,j-1),
            Math.max(dp(s1,s2,i-1,j),dp(s1,s2,i-1,j-1)));
        }

    }
}
```



### 方法二：dp函数自上而下-保存中间结果

使用map就是有点废GC和内存

```java
class Solution {
    public HashMap<String,Integer> map=new HashMap<>();
    public int longestCommonSubsequence(String text1, String text2) {
        return dp(text1,text2,text1.length()-1,text2.length()-1);
    }

    public int dp(String s1,String s2,int i,int j){
        if(map.containsKey(i+"_"+j)) return map.get(i+"_"+j);
        if(i==-1) return 0;
        if(j==-1) return 0;
        
        int res=0;
        if(s1.charAt(i)==s2.charAt(j)){
            res=1+dp(s1,s2,i-1,j-1);
        }else{
            res=Math.max(dp(s1,s2,i,j-1),
            Math.max(dp(s1,s2,i-1,j),dp(s1,s2,i-1,j-1)));
        }
        map.put(i+"_"+j,res);
        return res;

    }
}
```





### 方法三：dp函数自下而上

**注意数组的边界，以及边界代表的含义，这一点和dp函数不同**



```java
class Solution {
    public int longestCommonSubsequence(String text1, String text2) {
        int m=text1.length(),n=text2.length();
        int[][] dp=new int[m+1][n+1];
        for(int i=1;i<m+1;i++)
            for(int j=1;j<n+1;j++){
                if(text1.charAt(i-1)==text2.charAt(j-1))
                    dp[i][j]=dp[i-1][j-1]+1;
                    //dp[i][j]=Math.max(dp[i-1][j],Math.max(dp[i][j-1],dp[i-1][j-1]))
                else dp[i][j]=Math.max(dp[i-1][j],dp[i][j-1]);
            }

        return dp[m][n];
    }
}
```



## 编辑距离【困难】

力扣地址：https://leetcode-cn.com/problems/edit-distance/





### 方法一：dp函数

```java
class Solution {
    
    public int minDistance(String word1, String word2) {
        return dp(word1,word2,word1.length()-1,word2.length()-1);
    }

    public int dp(String s1,String s2,int i,int j){
        if(i==-1) return j+1;
        if(j==-1) return i+1;

        if(s1.charAt(i)==s2.charAt(j)){
            return dp(s1,s2,i-1,j-1);
        }else{
            return 1+Math.min(dp(s1,s2,i,j-1),
            Math.min(dp(s1,s2,i-1,j),dp(s1,s2,i-1,j-1)));
        }
    }
}
```



### 方法二：dp数组-保存中间结果

```java
class Solution {
    HashMap<String,Integer> map=new HashMap<>();
    public int minDistance(String word1, String word2) {
        return dp(word1,word2,word1.length()-1,word2.length()-1);
    }

    public int dp(String s1,String s2,int i,int j){
        if(map.containsKey(i+"_"+j)) return map.get(i+"_"+j);
        if(i==-1) return j+1;
        if(j==-1) return i+1;

        int res=0;
        if(s1.charAt(i)==s2.charAt(j)){
            res=dp(s1,s2,i-1,j-1);
        }else{
            res=1+Math.min(dp(s1,s2,i,j-1),
            Math.min(dp(s1,s2,i-1,j),dp(s1,s2,i-1,j-1)));
        }
        map.put(i+"_"+j,res);
        return res;
    }
}
```



### 方法三：dp数组

**注意数组的边界，以及边界代表的含义，这一点和dp函数不同**

```java
class Solution {

    public int minDistance(String word1, String word2) {
        int m=word1.length(),n=word2.length();
        int[][] dp=new int[m+1][n+1];
        for(int i=0;i<=m;i++){
            dp[i][0]=i;
        }
        for(int j=0;j<=n;j++){
            dp[0][j]=j;
        }
        
        for(int i=1;i<=m;i++)
            for(int j=1;j<=n;j++){
                if(word1.charAt(i-1)==word2.charAt(j-1)){
                    dp[i][j]=dp[i-1][j-1];
                }else{
                    dp[i][j]=1+Math.min(dp[i][j-1],
                    Math.min(dp[i-1][j],dp[i-1][j-1]));
                }
            }

        return dp[m][n];

    }
}
```



##  最长回文子序列【中等】

力扣地址：https://leetcode-cn.com/problems/longest-palindromic-subsequence/



```java
class Solution {
    public int longestPalindromeSubseq(String s) {
        int n=s.length();
        int[][] dp=new int[n][n];
        for(int i=0;i<n;i++)
            dp[i][i]=1;
        for(int i=0;i<n;i++)
            for(int j=0;j<i;j++){
                dp[i][j]=0;
            }
        
        for(int i=n-2;i>=0;i--)
            for(int j=i+1;j<n;j++){
                if(s.charAt(i)==s.charAt(j)){
                    dp[i][j]=dp[i+1][j-1]+2;//注意是+2
                }else{
                    dp[i][j]=Math.max(dp[i][j-1],dp[i+1][j]);
                }
            }
        
        return dp[0][n-1];
    }
}
```





## 最长回文子串【中等-自己做的】

注意：`i<j`是不合法的，**就是0**，如果i的下标从1开始，那么下标为0的也是不合法的，`dp[0][j]`和`dp[i][0]`**要么就用不到**，用到了就是0

力扣地址：https://leetcode-cn.com/problems/longest-palindromic-substring/



`dp[i][j]`为以`s[i]`开头，以`s[j]`结尾的回文子串，如果不是`s[i...j]`不是回文子串，则`dp[i][j]=-1`。



```java
class Solution {
    public String longestPalindrome(String s) {
        int n=s.length();
        int[][] dp=new int[n][n];
        for(int i=0;i<n;i++)
            dp[i][i]=1;
        for(int i=0;i<n;i++)
            for(int j=0;j<i;j++){
                dp[i][j]=0;
            }
        
        //注意是倒着遍历，可以画一张表格看看
        for(int i=n-2;i>=0;i--)
            for(int j=i+1;j<n;j++){
                if(s.charAt(i)==s.charAt(j)){
                    if(dp[i+1][j-1]==-1)    dp[i][j]=-1;
                    else dp[i][j]=dp[i+1][j-1]+2;//注意是+2
                }else{
                    dp[i][j]=-1;
                }
            }
        int len=0;
        String res="";
        for(int i=0;i<n;i++)
            for(int j=0;j<n;j++){
                if(dp[i][j]!=-1 && dp[i][j]>len){
                    len=dp[i][j];
                    res=s.substring(i,j+1);
                }
            }
        return res;
    }
}
```



稍微优化一下

```java
class Solution {
    public String longestPalindrome(String s) {
        int n=s.length();
        int[][] dp=new int[n][n];
        for(int i=0;i<n;i++)
            dp[i][i]=1;
        for(int i=0;i<n;i++)
            for(int j=0;j<i;j++){
                dp[i][j]=0;
            }
        
        int len=1;
        String res=s.charAt(0)+"";

        //注意是倒着遍历，可以画一张表格看看
        for(int i=n-2;i>=0;i--)
            for(int j=i+1;j<n;j++){
                if(s.charAt(i)==s.charAt(j)){
                    if(dp[i+1][j-1]==-1)    dp[i][j]=-1;
                    else {
                        dp[i][j]=dp[i+1][j-1]+2;//注意是+2
                        if(dp[i][j]>len){
                            len=dp[i][j];
                            res=s.substring(i,j+1);
                        }
                    }
                }else{
                    dp[i][j]=-1;
                }
            }


        return res;
    }
}
```



或者

```java
class Solution {
    public String longestPalindrome(String s) {

        int n=s.length();
        int[][] dp=new int[n+1][n+1];

        for(int i=1;i<=n;i++){
            dp[i][i]=1;
        }
        int max=1;
        int mi=1,mj=1;
        for(int i=n-1;i>=1;i--)
            for(int j=i+1;j<=n;j++){
                //注意这里：dp[i+1][j-1]!=-1不能写成dp[i+1][j-1]!=0,因为0值有用的
                if(s.charAt(i-1)==s.charAt(j-1) && dp[i+1][j-1]!=-1){
                    dp[i][j]=dp[i+1][j-1]+2;
                    if(dp[i][j]>max) {
                        max=dp[i][j];
                        mi=i;
                        mj=j;
                    }
                }else{
                    dp[i][j]=-1;
                }
            }


        return s.substring(mi-1,mj);
    
    }
}
```



## 最长重复子数组【中等-自己做的】

力扣地址：https://leetcode-cn.com/problems/maximum-length-of-repeated-subarray/

`dp[i][j]`表示`nums1[0...i]`和`nums2[0...j]`中以`nums1[i]`和`nums2[j]`结尾的重复子数组，因此一定会满足`nums1[i]=nums2[j]`，否则`dp[i][j]]=0`

关系：

```java
if(nums1[i-1]==nums2[j-1]){
    dp[i][j]=dp[i-1][j-1]+1;
}else{
    dp[i][j]=0;
}
```

初值：nums[0]表示空数组，不表示nums的第一个值，这样一定要谨记，并且规定空数组和所有的子数组的重复子数组为0。

```java
for(int i=0;i<=m;i++)
    dp[i][0]=0;
for(int j=0;j<=n;j++)
    dp[0][j]=0;
```

解法：

```java
class Solution {
    public int findLength(int[] nums1, int[] nums2) {
        int m=nums1.length,n=nums2.length;
        int[][] dp=new int[m+1][n+1];
        for(int i=0;i<=m;i++)
            dp[i][0]=0;
        for(int j=0;j<=n;j++)
            dp[0][j]=0;

        int len=0;
        for(int i=1;i<=m;i++)
            for(int j=1;j<=n;j++){
                if(nums1[i-1]==nums2[j-1]){
                    dp[i][j]=dp[i-1][j-1]+1;
                    if(dp[i][j]>len) len=dp[i][j];
                }else{
                    dp[i][j]=0;
                }
            }

        return len;
    }
}
```



##  让字符串成为回文串的最少插入次数

> 力扣地址：https://leetcode-cn.com/problems/minimum-insertion-steps-to-make-a-string-palindrome/



`dp[i][j]`表示让字符串`s[i...j]`成为回文串的最少插入次数

```java
class Solution {
    public int minInsertions(String s) {
        int n=s.length();
        int[][] dp=new int[n][n];

        for(int i=n-2;i>=0;i--)
            for(int j=i+1;j<n;j++){
                if(s.charAt(i)==s.charAt(j)){
                    dp[i][j]=dp[i+1][j-1];
                }else{
                    dp[i][j]=1+Math.min(dp[i][j-1],dp[i+1][j]);
                }
            }

        return dp[0][n-1];
    }
}
```



## 正则表达式匹配【困难】

力扣地址：https://leetcode-cn.com/problems/zheng-ze-biao-da-shi-pi-pei-lcof/

```java
class Solution {
    public boolean isMatch(String s, String p) {
        return dp(s,p,0,0);
        
    }

    public boolean dp(String s,String p,int i,int j){
        //base;
        int m=s.length(),n=p.length();
        if(j==n){
            if(i==m) return true;
            else return false;
        }

        if(i==m){
            if((n-j)%2==1){
                return false;
            }
            for(int k=j;k+1<n;k=k+2){
                if(p.charAt(k+1)!='*') return false;
            }
            return true;

        }

        //logic
        if(s.charAt(i)==p.charAt(j) || p.charAt(j)=='.'){
            if(j+1<n && p.charAt(j+1)=='*'){//匹配0次或多次
                return dp(s,p,i,j+2) || dp(s,p,i+1,j);
            }else{//匹配一次
                return dp(s,p,i+1,j+1);
            }

        }else{
            if(j+1<n && p.charAt(j+1)=='*'){//匹配0次
                return dp(s,p,i,j+2);
            }else{//false
                return false;
                
            }
        }
        

    }
}
```



保存局部最优解

```java
class Solution {
    public HashMap<String,Boolean> map=new HashMap<>();
    public boolean isMatch(String s, String p) {
        return dp(s,p,0,0);
        
    }

    public boolean dp(String s,String p,int i,int j){

        
        //base;
        int m=s.length(),n=p.length();
        if(j==n){
            if(i==m) return true;
            else return false;
        }

        if(i==m){
            if((n-j)%2==1){
                return false;
            }
            for(int k=j;k+1<n;k=k+2){
                if(p.charAt(k+1)!='*') return false;
            }
            return true;

        }

        String key=i+"_"+j;
        if(map.containsKey(key)) return map.get(key);

        boolean res=false;

        //logic
        if(s.charAt(i)==p.charAt(j) || p.charAt(j)=='.'){
            if(j+1<n && p.charAt(j+1)=='*'){//匹配0次或多次
                res=dp(s,p,i,j+2) || dp(s,p,i+1,j);
            }else{//匹配一次
                res=dp(s,p,i+1,j+1);
            }

        }else{
            if(j+1<n && p.charAt(j+1)=='*'){//匹配0次
                res=dp(s,p,i,j+2);
            }else{//false
                res=false;
                
            }
        }

        map.put(key,res);
        return res;
        

    }
}
```



##  4键按键【651-中等】



```java


import java.util.HashMap;

public class Test9{

	static HashMap<String, Integer> map=new HashMap<String, Integer>();
	public static void main(String[] args) {
		System.out.println(maxA(7));
	}
	
	public static int maxA(int n){
		return dp(n,0,0);
	}
	
	//剩余次数为k时，屏幕上A为nums个，剪切板有copy个， 屏幕上最多有dp个
	public static int dp(int k,int nums,int copy){

		
		if(k<=0) return nums;
		
		
		String key=k+"_"+nums+"_"+copy;
		if(map.containsKey(key)) return map.get(key);
		int res=0;
		res=Math.max(dp(k-1,nums+1,copy), 
				Math.max(dp(k-2,nums,nums), dp(k-1,nums+copy,copy)));
		map.put(key, res);
		return res;
		
	}
	
}

```



另外的dp定义方式：

```java
	public static void main(String[] args) {
		System.out.println(maxA(7));
	}
	
	public static int maxA(int n){
		int[] dp=new int[n+1];//dp表示操作n次后，A最多有dp[n]个
		
		dp[0]=0;
		dp[1]=1;
		for(int i=1;i<=n;i++){
			dp[i]=dp[i-1]+1;//按A
			for(int j=2;j<i;j++){//第i次按C-V
				dp[i]=Math.max(dp[i],dp[j-2]*(i-j+1));
			}
		}
		
		return dp[n];
	}
```



## 高楼扔鸡蛋【困难】

力扣地址：https://leetcode-cn.com/problems/super-egg-drop/submissions/

`dp(k,n)`函数定义：当鸡蛋数为k，总楼层数为n时最坏情况下的**最小操作次数**

下面执行超时

```java
class Solution {
    HashMap<String,Integer> map=new HashMap<>();
    public int superEggDrop(int k, int n) {
        
        return dp(k,n);

    }

    public int dp(int k,int n){
        if(k==1) return n;
        if(n==0) return 0;
        String key=k+"_"+n;
        if(map.containsKey(key)) return map.get(key);

        int res=Integer.MAX_VALUE;
        for(int i=1;i<=n;i++){
            res=Math.min(res,Math.max(dp(k,i-1),dp(k-1,n-i))+1);
        }
        map.put(key,res);

        return res;
    }
}
```



换一种定义方式：

k个鸡蛋时，共扔m次，确定n层楼，`dp[k][m]=n`

状态转移方程`dp[k][m]=dp[k][m-1]+dp[k-1][m-1]+1;` 

- 鸡蛋不碎时仍为k个鸡蛋，扔的次数少了1，确定楼层的楼层`dp[k][m-1]`（向上）
- 鸡蛋碎时为k-1个鸡蛋，扔的次数少了1，确定楼层的楼层`dp[k-1][m-1]`（向下）
- 加上当前的一层楼，状态转移方程`dp[k][m]=dp[k][m-1]+dp[k-1][m-1]+1;` 

```java
class Solution {
    HashMap<String,Integer> map=new HashMap<>();
    public int superEggDrop(int k, int n) {
        
        return dp(k,n);

    }

    public int dp(int k,int n){
        
        //k个鸡蛋时，仍m次，确定n层楼，dp[k][m]=n
        int[][] dp=new int[k+1][n+1];

        int m=0;
        while(dp[k][m]<n){
            m++;
            for(int i=1;i<=k;i++){
                dp[i][m]=dp[i][m-1]+dp[i-1][m-1]+1;
            }
        }

        return m;
    }
}
```



## 戳气球【困难】

> 力扣地址：https://leetcode-cn.com/problems/burst-balloons/

方法一：回溯法

```java
class Solution {
    int result=Integer.MIN_VALUE;
    public int maxCoins(int[] nums) {
        ArrayList<Integer> list=new ArrayList<Integer>();
        for(int n:nums){
            list.add(n);
        }
        process(list,0);
        return result;
    }

    public void process(ArrayList<Integer> nums,int pre){

        if(nums.size()==0){
            result=Math.max(pre,result);
        }
        
        int size=nums.size();
        int temp;
        for(int i=0;i<size;i++){
            temp=nums.get(i);
            int res=0,left=1,right=1;
            if(i-1>=0) left=nums.get(i-1);
            if(i+1<=size-1) right=nums.get(i+1);
            res=pre+left*nums.get(i)*right;

            nums.remove(i);
            process(nums,res);
            nums.add(i,temp);
        }
    }
}
```

方法二：动态规划

`dp[i][j]`表示i和j之间（开区间）戳破所有气球的最高分数。

如果k是最后一个被戳破的气球，则

```java
dp[i][j]=Math.max(dp[i][j],dp[i][k]+dp[k][j]+points[i]*points[k]*points[j]);
```

解法如下：

```java
class Solution {
    int result=Integer.MIN_VALUE;
    public int maxCoins(int[] nums) {
        int n=nums.length;
        int[] points=new int[n+2];
        points[0]=points[n+1]=1;
        for(int i=1;i<=n;i++)
            points[i]=nums[i-1];

        int[][] dp=new int[n+2][n+2];
        
        for(int i=n+1;i>=0;i--)
            for(int j=0;j<=n+1;j++){
                for(int k=i+1;k<j;k++){
                    dp[i][j]=Math.max(dp[i][j],dp[i][k]+dp[k][j]+points[i]*points[k]*points[j]);
                }
            }
        
        return dp[0][n+1];
    }

}
```



## 0-1背包问题

**dp函数**：

```java
public class Main {

	static int N=3;
	static int W=4;
	static int[] wt={2,1,3};
	static int[] val={4,2,3};
	public static void main(String[] args) {
		System.out.println(dp(N-1,W));
	}

	//dp：[0..i]中 背包容量为w的最大价值
	public static int dp(int i,int w){
		if(w==0) return 0;
		
		if(i<0){ //不用判断==0，只用判断边界就行啦啦啦，不用自己找麻烦
			return 0;
		}
		
		int res1=0,res2=0;
		if(w-wt[i]<0){//不选择  ，注意这里只能不选择
			res1=dp(i-1,w);
		}else{
			res1=dp(i-1,w); //不选择
			res2=val[i]+dp(i-1,w-wt[i]);//选择
		}

		//选择，不选择
		int res=Math.max(res1,res2);
		return res;
	}
}

```

**dp数组：**

```java
import java.util.HashMap;
import java.util.Hashtable;
import java.util.Iterator;
import java.util.Map;
import java.util.TreeMap;



public class Main {
	static int N=3;
	static int W=4;
	static int[] wt={2,1,3};
	static int[] val={4,2,3};
	public static void main(String[] args) {
		int[][] dp=new int[N+1][W+1];
		
		for(int i=1;i<=N;i++)
			for(int j=1;j<=W;j++){
				if(j-wt[i-1]<0) dp[i][j]=dp[i-1][j];//注意这里只能不选择
				else dp[i][j]=Math.max(val[i-1]+dp[i-1][j-wt[i-1]],dp[i-1][j]);
			}
		System.out.println(dp[N][W]);

	}

}

```





## 分割等和子集【中等】

力扣地址：https://leetcode-cn.com/problems/partition-equal-subset-sum/

`dp[i][j]=true`表示在`nums[1...i]`中存在子集的和能够恰好装满重量为j的背包中

`dp[i][j]=false`表示在`nums[1...i]`中不存在子集的和能够恰好装满重量为j的背包中

> nums中的元素可以理解为重量

```java
class Solution {
    public boolean canPartition(int[] nums) {
        int sum=0;
        for(int t:nums)
            sum+=t;

        if(sum%2!=0) return false;
        
        sum=sum/2;
        int n=nums.length;
        boolean[][] dp=new boolean[n+1][sum+1];

        for(int i=0;i<=n;i++)
            dp[i][0]=true;

        for(int i=1;i<=n;i++)
            for(int j=1;j<=sum;j++){
                if(j-nums[i-1]<0) dp[i][j]=dp[i-1][j]; //注意这里
                else dp[i][j]=dp[i-1][j-nums[i-1]]||dp[i-1][j];
            }

        return dp[n][sum];
    }
}
```

dp函数：

```scala
class Solution {
    HashMap<String,Boolean> map=new HashMap<>();
    public boolean canPartition(int[] nums) {
        int sum=0;
        for(int t:nums) sum+=t;

        if(sum%2!=0) return false;

        sum=sum/2;
       //return dp(nums.length-1,sum,nums);
        int n=nums.length;
        boolean[][] dp=new boolean[n+1][sum+1];
        
        for(int i=0;i<=n;i++){
            dp[i][0]=true;
        }

        for(int i=1;i<=n;i++)
            for(int j=1;j<=sum;j++){
                if(j-nums[i-1]<0) dp[i][j]=dp[i-1][j];
                else dp[i][j]=dp[i-1][j-nums[i-1]] || dp[i-1][j];
            }

        return dp[n][sum];

    }
    public boolean dp(int i,int w,int[] nums){//超时，但正确
        if(w==0){
            return true;
        }
        if(i<0){
            return false;
        }

        String key=i+"_"+w;
        if(map.containsKey(key)) return map.get(key);
        
        boolean res1=false,res2=false;
        if(w-nums[i]<0){//不选择
            res1=dp(i-1,w,nums);
        }else{//不选择，选择
            res1=dp(i-1,w,nums);
            res2=dp(i-1,w-nums[i],nums);
        }
        boolean res= res1 || res2;
        map.put(key,res);
        return res;
    }
}
```



## 零钱兑换（二）【中等】

力扣地址：https://leetcode-cn.com/problems/coin-change-2/

`dp[i][j]`表示只用`coins[1...i]`凑成总金额为j的方式数。



```java
class Solution {
    public int change(int amount, int[] coins) {
        
        int n=coins.length;
        int[][] dp=new int[n+1][amount+1];
        for(int i=0;i<=n;i++)
            dp[i][0]=1;
        
        for(int i=1;i<=n;i++)
            for(int j=1;j<=amount;j++){
                if(j-coins[i-1]<0) dp[i][j]=dp[i-1][j];//注意这里
                else dp[i][j]=dp[i-1][j]+dp[i][j-coins[i-1]];  //即便选择了，因为硬币有无数个，所以还是从i开始
            }

        return dp[n][amount];
    }
}
```

dp函数：

```java
class Solution {
    HashMap<String,Integer> map=new HashMap<>();
    public int change(int amount, int[] coins) {
        return dp(coins.length-1,amount,coins);
    }

    public int dp(int i,int target,int[] coins){

        if(target==0){
            return 1;
        }

        if(i<0){
            return 0;
        }

        String key=i+"_"+target;
        if(map.containsKey(key)) return map.get(key);

        int res1=0,res2=0;

        if(target-coins[i]<0){//只能不选择了
            res1=dp(i-1,target,coins);
        }else{
            res1=dp(i-1,target,coins);//不选择
            res2=dp(i,target-coins[i],coins);//选择，因为硬币有无数个，所以还是从i开始
        }
        map.put(key,res1+res2);
        return res1+res2;
    }
}
```





## 打家劫舍【中等】

力扣地址：https://leetcode-cn.com/problems/house-robber/

**方法一:**

`dp[i]`表示在`nums[1...i]`中以`nums[i]`结尾的最高金额。

```java
class Solution {
    public int rob(int[] nums) {

        int n=nums.length;
        int[] dp=new int[n+1];
        for(int i=1;i<=n;i++)
            dp[i]=nums[i-1];

        for(int i=1;i<=n;i++)
            for(int j=0;j<i-1;j++){
                dp[i]=Math.max(dp[i],dp[j]+nums[i-1]);
            }

        int max=Integer.MIN_VALUE;
        for(int t:dp)
            max=Math.max(t,max);
        return max;
    }
}
```



**方法二：**

`dp(int[] nums,int i)`表示`nums[i...]`中的最高金额。

dp函数：自下而上

```java
class Solution {
    int[] memo;
    public int rob(int[] nums) {
        memo=new int[nums.length];
        Arrays.fill(memo,-1);
        return dp(nums,0);
    }

    public int dp(int[] nums,int i){

        if(i>=nums.length) return 0;
        if(memo[i]!=-1) return memo[i];

        int res=Integer.MIN_VALUE;
        res=Math.max(res,Math.max(nums[i]+dp(nums,i+2),
            dp(nums,i+1)));
        memo[i]=res;
        return res;
    }
}
```

转化为dp数组（那就是自上而下了）

```java
class Solution {

    public int rob(int[] nums) {
        int n=nums.length;
        int[] dp=new int[n+2];
        for(int i=n-1;i>=0;i--)
            dp[i]=Math.max(dp[i+1],nums[i]+dp[i+2]);

        return dp[0];
    }


}
```



## 打家劫舍2【中等】

力扣地址：https://leetcode-cn.com/problems/house-robber-ii/





```java
class Solution {
    public int rob(int[] nums) {
        if(nums.length==1) return nums[0];
        int n=nums.length;
        return Math.max(dp(nums,0,n-2),dp(nums,1,n-1));
    }

    
    public int dp(int[] nums,int s,int e){
        int n=nums.length;
        int[] dp=new int[n+2];
        for(int i=e;i>=s;i--)
            dp[i]=Math.max(dp[i+1],nums[i]+dp[i+2]);

        return dp[s];
    }
}
```



## 打家劫舍3【中等】

力扣地址：https://leetcode-cn.com/problems/house-robber-iii/



```java
class Solution {
    HashMap<TreeNode,Integer> map=new HashMap<>();
    public int rob(TreeNode root) {
        return process(root);
    }

    public int process(TreeNode root){
        if(root==null) return 0;
        if(map.containsKey(root)) return map.get(root);

        //拿了
        int solu1=root.val+(root.left==null?0:(process(root.left.left)+process(root.left.right)))+(root.right==null?0:(process(root.right.left)+process(root.right.right)));

        //没na
        int solu2=process(root.left)+process(root.right);

        int res=Math.max(solu1,solu2);
        map.put(root,res);
        return res;
    }
}
```



## 目标和

力扣地址：https://leetcode-cn.com/problems/target-sum/





```java
class Solution {
    HashMap<String,Integer> map=new HashMap<>();
    public int findTargetSumWays(int[] nums, int target) {
        return dp(nums,target,0);
    }

    //i从0开始
    //dp函数表示nums[i...]中表达式为target的数目
    public int dp(int[] nums, int target,int i){
        
        if(i>=nums.length){//选完了
            if(target==0) return 1;
            else return -1;
        }

        String key=target+"_"+i;
        if(map.containsKey(key)) return map.get(key);

        int res=0;
        //只能选择nums[i]
        int r1=dp(nums,target+nums[i],i+1),r2=dp(nums,target-nums[i],i+1);
        if(r1!=-1){
            res+=r1;
        }
        if(r2!=-1){
            res+=r2;
        }
        map.put(key,res);
        return res;
        
    }
}
```

