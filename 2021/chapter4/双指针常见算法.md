

# 快慢指针

## 判断链表是否有环

**从同一位置走**，一个走一步，一个走两步，**如果有环肯定会相遇** （有环时永远不会出现非空的情况）

141. 环形链表

力扣地址：https://leetcode-cn.com/problems/linked-list-cycle/submissions/



```java
/**
 * Definition for singly-linked list.
 * class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode(int x) {
 *         val = x;
 *         next = null;
 *     }
 * }
 */
public class Solution {
    public boolean hasCycle(ListNode head) {
        ListNode slow=head,fast=head;
        while(fast!=null && fast.next!=null){
            fast=fast.next.next;
            slow=slow.next;
            if(fast==slow)//注意一定会相遇
                return true;
        }
        return false;
    }
}
```



## 环的起始位置

142. 环形链表 II

https://leetcode-cn.com/problems/linked-list-cycle-ii/





```java
public class Solution {
    public ListNode detectCycle(ListNode head) {
        ListNode slow=head,fast=head;
        
        while(fast!=null && fast.next!=null){
            fast=fast.next.next;
            slow=slow.next;
            if(slow==fast) break;//判断是否有环
        }
        if(fast==null) return null;//没环，这里错误，ListNode只有一个结点时就错了
        slow=head;
        while(slow!=fast){
            slow=slow.next;
            fast=fast.next;
        }
        return slow;
    }
}
```

下面的是对的：

```java
public class Solution {
    public ListNode detectCycle(ListNode head) {
        if(head==null) return null;
        ListNode slow=head,fast=head;
        boolean flag=false; //判断是否有环
        while(fast!=null && fast.next!=null){
            fast=fast.next.next;
            slow=slow.next;
            if(fast==slow) {
                flag=true;
                break;
            }
        }
        if(!flag){ //一定要用这个
            return null;
        }
        slow=head;
        while(slow!=null && fast!=null){
            if(slow==fast){
                return slow;
            }
            slow=slow.next;
            fast=fast.next;
        }
        return null;
    }
}
```





## 链表的中点

876. 链表的中间结点

https://leetcode-cn.com/problems/middle-of-the-linked-list/



```java
public Node midNode(Node head){
	Node slow=head,fast=head;
    while(fast!=null && fast.next!=null){
    	fast=fast.next.next;
        slow=slow.next;
    }
    return slow;
    //奇数个节点，在中点位置，偶数个节点在中间偏右的位置
}
```



## 链表中倒数第k个节点

力扣地址：https://leetcode-cn.com/problems/lian-biao-zhong-dao-shu-di-kge-jie-dian-lcof/



```java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode(int x) { val = x; }
 * }
 */
class Solution {
    public ListNode getKthFromEnd(ListNode head, int k) {
        ListNode slow=head,fast=head;

        int count=1;
        while(fast!=null && count<=k){
            fast=fast.next;
            count++;
        }
        if(count<=k){
            return null;
        }else {
            while(fast!=null){
                fast=fast.next;
                slow=slow.next;
            }
            return slow;
                
        }
    }
}
```

两种解法应该一样

```java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode(int x) { val = x; }
 * }
 */
class Solution {
    public ListNode getKthFromEnd(ListNode head, int k) {

        if(head==null) return null;
        int count=1;
        ListNode fast=head;
        while(fast!=null && count<k){
            fast=fast.next;
            count++;
        }
        if(fast==null) return null;
        
        ListNode slow=head;
        fast=fast.next;

        while(fast!=null){
            fast=fast.next;
            slow=slow.next;
        }
        return slow;


    }
}
```





# 左右指针

左右指针，一般用在数组问题上，实际上是两个索引

## 二分查找

[点击打开二分查找](二分查找.md)





## 二数之和

对于升序的数组可以这样做

```java
    public int[] twoSum(int[] nums, int target) {
        int left=0,right=nums.length-1;
        while(left<right){//因为必须是两个数才行，所以是小于
            int sum=nums[left]+nums[right];
            if(sum==target)
                return new int[]{left+1,right+1};
            else if(sum<target)
                left++;
            else if(sum>target)
                right--;
            
        }
        
        return new int[]{-1,-1};
    }
```



## 滑动窗口

