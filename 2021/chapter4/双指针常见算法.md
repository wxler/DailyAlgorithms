

# 快慢指针

## 判断链表是否有环

力扣地址：https://leetcode-cn.com/problems/linked-list-cycle/submissions/



```java
/**
 * Definition for singly-linked list.
 * class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode(int x) {
 *         val = x;
 *         next = null;
 *     }
 * }
 */
public class Solution {
    public boolean hasCycle(ListNode head) {
        ListNode slow=head,fast=head;
        while(fast!=null && fast.next!=null){
            fast=fast.next.next;
            slow=slow.next;
            if(fast==slow)//注意一定会相遇
                return true;
        }
        return false;
    }
}
```



## 环的起始位置

```java

public Node getStartLocation(Node head){
	Node slow=head,fast=head;
    
    while(fast!=null && fast.next!=null){
    	fast=fast.next.next;
        slow=slow.next;
        if(slow==fast) break;//判断是否有环
    }
    if(fast==null) return null;//没环
    slow=head;
    while(slow!=fast){
    	slow=slow.next;
        fast=fast.next;
    }
    return slow;
    
}
```





## 链表的中点

```java
public Node midNode(Node head){
	Node slow=head,fast=head;
    while(fast!=null && fast.next!=null){
    	fast=fast.next.next;
        slow=slow.next;
    }
    return slow;
    //奇数个节点，在中点位置，偶数个节点在中间偏右的位置
}
```



## 链表中倒数第k个节点

力扣地址：https://leetcode-cn.com/problems/lian-biao-zhong-dao-shu-di-kge-jie-dian-lcof/



```java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode(int x) { val = x; }
 * }
 */
class Solution {
    public ListNode getKthFromEnd(ListNode head, int k) {
        ListNode slow=head,fast=head;

        int count=1;
        while(fast!=null && count<=k){
            fast=fast.next;
            count++;
        }
        if(count<=k){
            return null;
        }else {
            while(fast!=null){
                fast=fast.next;
                slow=slow.next;
            }
            return slow;
                
        }
    }
}
```





# 左右指针

左右指针，一般用在数组问题上，实际上是两个索引

## 二分查找

[点击打开二分查找](二分查找.md)





## 二数之和

对于升序的数组可以这样做

```java
    public int[] twoSum(int[] nums, int target) {
        int left=0,right=nums.length-1;
        while(left<right){//因为必须是两个数才行，所以是小于
            int sum=nums[left]+nums[right];
            if(sum==target)
                return new int[]{left+1,right+1};
            else if(sum<target)
                left++;
            else if(sum>target)
                right--;
            
        }
        
        return new int[]{-1,-1};
    }
```



## 滑动窗口

