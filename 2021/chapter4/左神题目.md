# 递归和动态规划



## 矩阵的最小路径和

牛客地址：https://www.nowcoder.com/practice/2fb62a4500af4f4ba5686c891eaad4a9?tpId=101&&tqId=33254&rp=1&ru=/ta/programmer-code-interview-guide&qru=/ta/programmer-code-interview-guide/question-ranking





```java
import java.util.Scanner;
import java.util.Arrays;
public class Main{
    static int[][] memo;
    public static void main(String[] args){
        Scanner sc=new Scanner(System.in);
        int i=sc.nextInt(),j=sc.nextInt();
        int[][] arr=new int[i][j];
        memo=new int[i][j];
        for(int[] t:memo)
            Arrays.fill(t,-1);
        for(int a=0;a<i;a++)
            for(int b=0;b<j;b++)
                arr[a][b]=sc.nextInt();
        
        System.out.print(dp(arr,0,0));
    }
    //dp（i,j)表示从arr[0,0]走到arr[i,j]的最小路径，可以通过
    //初始i,j=0,0
    public static int dp(int[][] arr,int i,int j){
        
        if(i==arr.length-1 && j==arr[0].length-1)
            return arr[i][j];
        
        if(memo[i][j]!=-1) return memo[i][j];
        
        int res=arr[i][j];
        if(i>=arr.length-1){
            res+=dp(arr,i,j+1);
            memo[i][j]=res;
            return res;
        }
        
        if(j>=arr[0].length-1){
            res+=dp(arr,i+1,j);
            memo[i][j]=res;
            return res;
        }
        
        res+=Math.min(dp(arr,i,j+1),dp(arr,i+1,j));
        memo[i][j]=res;
        return res;
        
    }
   
}
```





## 机器人达到指定位置方法数



```java
import java.util.Scanner;
import java.util.HashMap;
public class Main{
    //int N,int M,int K,int P
    static HashMap<String,Integer> map=new HashMap<>();
    static int N,M,K,P,mod=(int)(1e9 + 7);
    public static void main(String[] args){
        Scanner sc=new Scanner(System.in);
        N=sc.nextInt();
        M=sc.nextInt();
        K=sc.nextInt();
        P=sc.nextInt();
        
        
        
        System.out.print(dp1());
        //System.out.print(dp(M,K)%mod);
    }
    
    //dp[i][j]表示当前位置为i，步数为j时到达P的方案数，可以通过
    //有值
    public static int dp1(){
        int[][] dp=new int[N+1][K+1];
        dp[P][0]=1;
        for(int j=1;j<=K;j++)
            for(int i=1;i<=N;i++){
                if(i-1<=0) dp[i][j]=dp[i+1][j-1]%mod;
                else if(i+1>N) dp[i][j]=dp[i-1][j-1]%mod;
                else dp[i][j]=(dp[i+1][j-1]+dp[i-1][j-1])%mod;
            }
        return dp[M][K];
    }
    //dp[i][j]表示当前位置为i，步数为j时到达P的方案数
    //无值：想想元素的取值范围，只能竖着遍历
    public static int dp2(){
        int[][] dp=new int[N+1][K+1];
        dp[P][0]=1;
        for(int i=1;i<=N;i++)
            for(int j=1;j<=K;j++){
                if(i-1<=0) dp[i][j]=dp[i+1][j-1];
                else if(i+1>N) dp[i][j]=dp[i-1][j-1];
                else dp[i][j]=dp[i+1][j-1]+dp[i-1][j-1];
            }
        return dp[M][K];
    }
    
    //dp(cur,k)表示当前位置为cur，步数为K时到达P的方案数，栈溢出
    //起始cur=M,k=K
    public static int dp(int cur,int k){
        
        if(k==0){
            if(cur==P) return 1;
            else return 0;
        }
        //选择
        //dp(cur+1,k-1)
        //dp(cur-1,k-1)
        String key=cur+"_"+k;
        if(map.containsKey(key)) return map.get(key);
        
        
        int res=0;
        if(cur==N){
            res=dp(cur-1,k-1);
            map.put(key,(int)(res%(1e9+7)));
            return res;
        }
        
        if(cur==0){
            res=dp(cur+1,k-1);
            map.put(key,(int)(res%(1e9+7)));
            return res;
        }
        
        res=dp(cur+1,k-1)+dp(cur-1,k-1);
        map.put(key,(int)(res%(1e9+7)));
        return res;
    }
}
```





## 最长公共子序列

牛客地址：https://www.nowcoder.com/practice/4727c06b9ee9446cab2e859b4bb86bb8?tpId=101&&tqId=33099&rp=1&ru=/ta/programmer-code-interview-guide&qru=/ta/programmer-code-interview-guide/question-ranking



```java
import java.util.Scanner;
import java.util.HashMap;

public class Main{
    static String s1,s2;
    static HashMap<String,String> memo=new HashMap<String,String>();
    public static void main(String[] args){
        Scanner sc=new Scanner(System.in);
        s1=sc.next();
        s2=sc.next();
//         memo=new int[s1.length()-1][s2.length()-1)];
//         for(int[] t:memo)
//             Arrays.fill(t,-1);
        String res=dp(s1.length()-1,s2.length()-1);
        if(res.length()==0) System.out.print(-1);
        else System.out.print(res);
    }
    //dp(i,j)表示s1[0..i]和s2[0...j]的最长公共子序列，可以通过
    //i=s1.length()-1,j=s2.length()-1
    public static String dp(int i,int j){
        
        if(i<0) return "";
        if(j<0) return "";
        
        String key=i+"_"+j;
        if(memo.containsKey(key)) return memo.get(key);
        
        String res="";
        if(s1.charAt(i)==s2.charAt(j)){
            res=dp(i-1,j-1)+s1.charAt(i);
        }else{
            String solu1=dp(i,j-1);
            String solu2=dp(i-1,j);
            if(solu1.length()>solu2.length())
                res=solu1;
            else res=solu2;
        }
        memo.put(key,res);
        return res;
        
    }
}
```





## 最长公共子串

牛客题目：https://www.nowcoder.com/practice/210741385d37490c97446aa50874e62d?tpId=101&&tqId=33101&rp=1&ru=/ta/programmer-code-interview-guide&qru=/ta/programmer-code-interview-guide/question-ranking



```java
import java.util.Scanner;
import java.util.HashMap;
public class Main{
    
    static String s1,s2;
    static HashMap<String,String> memo=new HashMap<>();
    public static void main(String[] args){
        Scanner sc=new Scanner(System.in);
        s1=sc.next();
        s2=sc.next();
//         String result="",s="";
        
           //调用dp运行超时
//         for(int i=s1.length()-1;i>=0;i--)
//             for(int j=s2.length()-1;j>=0;j--){
//                 s=dp(i,j);
//                 if(s.length()>result.length()) result=s;
//             }
        
//         System.out.println(result);
        System.out.println(dp1());
    }
    
    //可以通过
    public static String dp1(){
        //dp[i][j]表示以s1[i],s2[j]为结尾的最长公共子串
        int[][] dp=new int[s1.length()+1][s2.length()+1];
        String result="";
        for(int i=1;i<=s1.length();i++)
            for(int j=1;j<=s2.length();j++){
                if(s1.charAt(i-1)==s2.charAt(j-1)){
                    dp[i][j]=dp[i-1][j-1]+1;
                    if(dp[i][j]>result.length()) result=s1.substring(i-dp[i][j],i);
                }
                
            }
        if(result.length()==0) return "-1";
        else return result;
    }
    
    //dp(int i,int j)表示以s1[i],s2[j]为结尾的最长公共子串
    //i=s1.length()-1,j=s2.length()-1
    public static String dp(int i,int j){
        if(i<0) return "";
        if(j<0) return "";
        
        String key=i+"_"+j;
        if(memo.containsKey(key)) return memo.get(key);
        
        //选择
        if(s1.charAt(i)==s2.charAt(j)){
            String res=dp(i-1,j-1)+s1.charAt(i);
            memo.put(key,res);
            return res;
        }else{
            return "";
        }
    }
}
```





## 最小编辑代价

地址：https://www.nowcoder.com/practice/dfa502cf6a914fb5b98c59c56619e96c?tpId=101&&tqId=33111&rp=1&ru=/ta/programmer-code-interview-guide&qru=/ta/programmer-code-interview-guide/question-ranking

`dp(i,j)`表示`s1[0..i]`和`s2[0...j]`的编辑代价

```java
import java.util.Scanner;
import java.util.HashMap;
public class Main{
    static HashMap<String,Integer> memo=new HashMap<String,Integer>();
    static String s1,s2;
    static int[] cost=new int[3];
    public static void main(String[] args){
        Scanner sc=new Scanner(System.in);
        s1=sc.next();
        s2=sc.next();
        for(int i=0;i<3;i++)
            cost[i]=sc.nextInt();
        //System.out.print(dp(s1.length()-1,s2.length()-1));
        System.out.print(dp1());
    }
    
    public static int dp1(){
        
        int[][] dp=new int[s1.length()+1][s2.length()+1];
        //dp[0][0]=0;
        for(int i=1;i<=s1.length();i++){//删除
            for(int t=0;t<i;t++)
                dp[i][0]+=cost[1];
        }
        for(int j=1;j<=s2.length();j++){//插入
            for(int t=0;t<j;t++)
                dp[0][j]+=cost[0];
        }
        
        for(int i=1;i<=s1.length();i++)
            for(int j=1;j<=s2.length();j++){
                if(s1.charAt(i-1)==s2.charAt(j-1)){
                    dp[i][j]=dp[i-1][j-1];
                }else{
                    dp[i][j]=Math.min(cost[0]+dp[i][j-1],
                           Math.min(cost[1]+dp[i-1][j],cost[2]+dp[i-1][j-1]));
                }
            }
        return dp[s1.length()][s2.length()];
    }
    
    //将s1变为s2，初始i=s1.length-1,j=s2.length-1
    //dp(i,j)：s1[0..i]和s2[0...j]的编辑代价
    public static int dp(int i,int j){
        
        
        int res=0;
        if(i<0){//只能插入了
            for(int k=0;k<=j;k++){
                res+=cost[0];
            }
            return res;
        }
        if(j<0){//只能删除了
            for(int k=0;k<=i;k++){
                res+=cost[1];
            }
            return res;
        }
        
        String key=i+"_"+j;
        if(memo.containsKey(key)) return memo.get(key);
        
        //选择
        if(s1.charAt(i)==s2.charAt(j)){
            return dp(i-1,j-1);
        }else{
            //插入、删除、替换
            res=Math.min(cost[0]+dp(i,j-1),
                           Math.min(cost[1]+dp(i-1,j),cost[2]+dp(i-1,j-1)));
            memo.put(key,res);
            return res;
            
        }
    }
    
}
```





## 字符串的交错组成

地址：https://www.nowcoder.com/practice/1fdefa4178f7460d93738b28441e1277?tpId=101&&tqId=33112&rp=1&ru=/ta/programmer-code-interview-guide&qru=/ta/programmer-code-interview-guide/question-ranking

`dp(i,j)`表示：`aim[0..i]`是否包含`s[0..j]`



```java
import java.util.Scanner;

public class Main{
    static String s1,s2,aim;
    public static void main(String[] args){
        Scanner sc=new Scanner(System.in);
        s1=sc.next();
        s2=sc.next();
        aim=sc.next();
        
        if((s1.length()+s2.length())!=aim.length()) {
            System.out.print("NO");
            return;
        }
        boolean f1=dp1(aim,s1);
        boolean f2=dp1(aim,s2);
        if(f1 && f2){
            System.out.print("YES");
        }else System.out.print("NO");
        //System.out.print(dp(aim.length()-1,s1.length()-1));
    }
    
    public static boolean dp1(String a,String s){
        
        boolean[][] dp=new boolean[a.length()+1][s.length()+1];
        dp[0][0]=true;
        for(int i=1;i<=a.length();i++){
            dp[i][0]=true;
        }
//         for(int j=1;j<=s.length();j++){
//             dp[0][j]=false;
//         }
        for(int i=1;i<=a.length();i++)
            for(int j=1;j<=s.length();j++){
                if(a.charAt(i-1)==s.charAt(j-1)){
                    dp[i][j]=dp[i-1][j-1];
                }else dp[i][j]=dp[i-1][j];
            }
        return dp[a.length()][s.length()];
        
    }
    
    
    /*
    //dp(i,j)：aim[0..i]是否包含s[0..j]
    public static boolean dp(int i,int j){
        
        if(i<0){
            if(j<0) return true;
            else return false;
        }
        if(j<0){
            return true;
//             if(i<0) return true;
//             else return false;
        }
        
        //选择
        if(aim.charAt(i)==s1.charAt(j)){
            return dp(i-1,j-1);
        }else{
            return dp(i-1,j);
        }
        
    }
    */
}
```





## 龙与地下城游戏问题

> https://www.nowcoder.com/practice/c0ca4c9e65144af69ada03febaa0e33a?tpId=101&&tqId=33113&rp=1&ru=/ta/programmer-code-interview-guide&qru=/ta/programmer-code-interview-guide/question-ranking





```java
import java.util.Scanner;
import java.util.HashMap;
public class Main{
    public static void main(String[] args){
        Scanner sc=new Scanner(System.in);
        int n=sc.nextInt(),m=sc.nextInt();
        int[][] arr=new int[n][m];
        
        
        for(int i=0;i<n;i++){
            for(int j=0;j<n;j++)
                arr[i][j]=sc.nextInt();
        }
        System.out.print(dp(arr,n,m));
    }
    
    public static int dp(int[][] arr,int n,int m){
        //dp(i,j)表示：从dp[m-1][n-1]到dp[i][i]所具备的血量，可能表述的不是太准确
        int[][] dp=new int[n][m];
        dp[n-1][m-1]=arr[n-1][m-1]>0?1:1-arr[n-1][m-1];
        for(int i=n-2;i>=0;i--){
            dp[i][m-1]=Math.max(dp[i+1][m-1]-arr[i][m-1],1);
        }
        for(int j=m-2;j>=0;j--){
            dp[n-1][j]=Math.max(dp[n-1][j+1]-arr[n-1][j],1);
        }
        
        for(int i=n-2;i>=0;i--)
            for(int j=m-2;j>=0;j--){
                int right=Math.max(dp[i][j+1]-arr[i][j],1);
                int up=Math.max(dp[i+1][j]-arr[i][j],1);
                dp[i][j]=Math.min(right,up);
            }
        
        return dp[0][0];
        
        
    }
}
```



下面这个我不知道那里错了

```java
import java.util.Scanner;
import java.util.HashMap;
public class Main{
    static int n,m;
    static int[][] arr;
    static HashMap<String,Node> memo=new HashMap<>();
    public static void main(String[] args){
        Scanner sc=new Scanner(System.in);
        int n=sc.nextInt(),m=sc.nextInt();
        arr=new int[n][m];
        
        
        for(int i=0;i<n;i++){
            for(int j=0;j<n;j++)
                arr[i][j]=sc.nextInt();
        }
        System.out.print(dpArr());
        //System.out.print(dp(n-1,m-1).need);
        //System.out.print(result.sum+"\t"+result.minTop);
        //System.out.print(minHP1(arr));

    }
    
    static class Node{
        int need,sum;
        public Node(int n,int s){
            this.need=n;
            this.sum=s;
        }
    }
    
    public static int dpArr(){
        Node[][] dp=new Node[n][m];

        int need=Integer.MIN_VALUE,sum=0,tn=0;
        for(int i=0;i<n;i++){
            sum+=arr[i][0];
            tn=(sum>0)?1:1-sum;
            if(tn>need){
                need=tn;
            }
            dp[i][0]=new Node(need,sum);
        }
        need=Integer.MIN_VALUE;sum=0;tn=0;
        for(int j=0;j<m;j++){
            sum+=arr[0][j];
            tn=(sum>0)?1:1-sum;
            if(tn>need){
                need=tn;
            }
            dp[0][j]=new Node(need,sum);
        }

        for(int i=1;i<n;i++)
            for(int j=1;j<n;j++){
                Node solu1=dp[i][j-1];//向右
                Node solu2=dp[i-1][j];//向下
                Node solu=null;
                if(solu1.need==solu2.need){
                    solu=(solu1.sum>solu2.sum?solu1:solu2);
                }else if(solu1.need<solu2.need){
                    solu=solu1;
                }else{
                    solu=solu2;
                }

                tn=0;need=0;sum=0;
                sum=arr[i][j]+solu.sum;
                tn=(sum>0)?1:1-sum;
                need=Math.max(tn,solu.need);
                dp[i][j]=new Node(need,sum);
            }

        return dp[n-1][m-1].need;
    }
    
    /*
    //dp：[0,0]到[i,j]在具有最少必备血量的情况下的剩余血量和最少必备血量
    public static Node dp(int i,int j){
        String key=i+"_"+j;
        if(memo.containsKey(key)) return memo.get(key);
        Node result=null;
        
        if(i==0){
            int need=Integer.MIN_VALUE,sum=0,tn=0;
            for(int t=0;t<=j;t++){
                sum+=arr[0][t];
                tn=(sum>0)?1:1-sum;
                if(tn>need){
                    need=tn;
                }
            }
            result=new Node(need,sum);
            memo.put(key,result);
            return result;
        }
        
        if(j==0){
            int need=Integer.MIN_VALUE,sum=0,tn=0;
            for(int t=0;t<=i;t++){
                sum+=arr[t][0];
                tn=(sum>0)?1:1-sum;
                if(tn>need){
                    need=tn;
                }
            }
            result=new Node(need,sum);
            memo.put(key,result);
            return result;
        }
        
        //选择
        Node solu1=dp(i,j-1);//向右
        Node solu2=dp(i-1,j);//向下
        Node solu=(solu1.need<solu2.need?solu1:solu2);
        int need=0,sum=0;
        sum=arr[i][j]+solu.sum;
        need=(sum>0)?1:1-sum;
        if(need<solu.need) need=solu.need;
        result=new Node(need,sum);
        memo.put(key,result);
        return result;
    }
   */
}
```





## 排成一条线的纸牌博弈问题

> 地址：https://www.nowcoder.com/practice/19c98d950b3347d19f991d10bde12288?tpId=101&&tqId=33159&rp=1&ru=/ta/programmer-code-interview-guide&qru=/ta/programmer-code-interview-guide/question-ranking





递归法：超时：

```java
import java.util.Scanner;
public class Main{
    
    static int[] arr;
    public static void main(String[] args){
        Scanner sc=new Scanner(System.in);
        int n=sc.nextInt();
        arr=new int[n];
        for(int i=0;i<n;i++)
            arr[i]=sc.nextInt();
        
        System.out.print(win(0,n-1));
    }
    
    public static int win(int i,int j){
        return Math.max(f1(i,j),f2(i,j));
    }
    
    //（先拿的人）f1(i,j)：从arr[i..j]得到的分数（玩家拿肯定拿最好的）
    public static int f1(int i,int j){
        //if(i>j) return 0;//这个应该也可以
        if(i==j) return arr[i];
        //选择：拿了之后就编程后拿的人了
        return Math.max(arr[i]+f2(i+1,j),arr[j]+f2(i,j-1));
    }
    
    //（后拿的人）将最差的情况流程对手
    public static int f2(int i,int j){
        if(i==j) return 0;
        return Math.min(f1(i+1,j),f1(i,j-1)); 
    }
    

}
```

dp数组法：

```java
import java.util.Scanner;
public class Main{
    
    static int[] arr;
    public static void main(String[] args){
        Scanner sc=new Scanner(System.in);
        int n=sc.nextInt();
        arr=new int[n];
        for(int i=0;i<n;i++)
            arr[i]=sc.nextInt();
        System.out.print(dp());
        
    }
    
    public static int dp(){
        int n=arr.length;
        int[][] s1=new int[n+1][n+1];//先拿
        int[][] s2=new int[n+1][n+1];
        
        for(int i=1;i<=n;i++){
            s1[i][i]=arr[i-1];
            s2[i][i]=0;
        }
        
        for(int i=n-1;i>=1;i--)
            for(int j=i+1;j<=n;j++){
                s1[i][j]=Math.max(arr[i-1]+s2[i+1][j],arr[j-1]+s2[i][j-1]);
                s2[i][j]=Math.min(s1[i+1][j],s1[i][j-1]); 
            }
        return Math.max(s1[1][n],s2[1][n]);
    }
    

    

    

}
```



## 表达式得到期望结果的组合

先放弃了，有空看解析。

力扣：https://www.nowcoder.com/practice/9690bd908d5b4f9b91640fa835ef6f4f?tpId=101&&tqId=33115&rp=1&ru=/ta/programmer-code-interview-guide&qru=/ta/programmer-code-interview-guide/question-ranking



```java
import java.util.Scanner;

public class Main{

    static long mod=(long)(1e9+7);
    public static void main(String[] args){
        Scanner sc=new Scanner(System.in);
        String s=sc.next();
        String desired=sc.next();
        boolean flag=false;
        if("true".equals(desired)) flag=true;
        if(s.length()==1) {
            boolean t=s.charAt(0)=='1'?true:false;
            if(t==flag)
                System.out.print(1);
            else System.out.print(0);
            return;
        }
        
        int n=s.length()/2;
        int[] nums=new int[n+1];
        char[] ops=new char[n];
        int c1=0,c2=0;
        for(int i=0;i<s.length();i++){
            if(i%2==0) nums[c1++]=s.charAt(i)-'0';
            else ops[c2++]=s.charAt(i);
        }
        

        
        System.out.print(dp3(nums,ops,0,nums.length-1,flag));
        //System.out.print(dp1(nums,ops,flag));
        
    }
    
        //i=0,j=s1.length()-1,flag=desired
    //dp(i,j)：表示s[i...j]达到flag的方案数
    public static int dp3(int[] nums,char[] ops,int i,int j,boolean flag){
        
//         if(i>j) return 0;
        
        int count=0;
        //选择
//         int solu1=dp(nums,ops,i+1,j,true);
//         int solu2=dp(nums,ops,i,j-1);
        boolean fi=nums[i]==1?true:false;
        boolean fj=nums[j]==1?true:false;
        
        if(i==j){
            if(fi==flag) return 1;
            else return 0;
        }
        
        if(j-i==1){//剩余2个
        	return operate(fi,fj,ops[i])==flag?1:0;
        }
        
        boolean res1=operate(fi,flag,ops[i]);
        if(res1==flag) count+=dp(nums,ops,i+1,j,flag);
        
        boolean res1_1=operate(fi,!flag,ops[i]);
        if(res1_1==flag) count+=dp(nums,ops,i+1,j,!flag);
        
        boolean res2=operate(fj,flag,ops[j-1]);
        if(res2==flag) count+=dp(nums,ops,i,j-1,flag);
        
        boolean res2_1=operate(fj,!flag,ops[j-1]);
        if(res2_1==flag) count+=dp(nums,ops,i,j-1,!flag);
        
        //System.out.println(i+","+j+","+flag+":"+count);
        return count%(int)mod;
    }
    
    
    public static long dp1(int[] nums,char[] ops,boolean flag){
        //返回dp[0][n-1][0]
        //第一个二维数组：等于flag的方案数
        int n=nums.length;
        long[][][] dp=new long[n][n][2];
        for(int i=0;i<n;i++){
            boolean f=nums[i]==1?true:false;
            if(f==flag) dp[i][i][0]=1;
            else dp[i][i][1]=1;
        }
        
        for(int i=n-2;i>=0;i--)
            for(int j=i+1;j<n;j++){
                
                long count1=0,count2=0;
                boolean fi=nums[i]==1?true:false;
                boolean fj=nums[j]==1?true:false;
                
                boolean res1=operate(fi,flag,ops[i]);
                if(res1==flag) count1+=dp[i+1][j][0];
                else count2+=dp[i+1][j][0];
                
                boolean res1_1=operate(fi,!flag,ops[i]);
                if(res1_1==(!flag)) count1+=dp[i+1][j][1];
                else count2+=dp[i+1][j][1];

                boolean res2=operate(fj,flag,ops[j-1]);
                if(res2==flag) count1+=dp[i][j-1][0];
                else count2+=dp[i][j-1][0];

                boolean res2_1=operate(fj,!flag,ops[j-1]);
                if(res2_1==(!flag)) count1+=dp[i][j-1][1];
                else count2+=dp[i][j-1][1];
                
                dp[i][j][0]=count1%mod;
                dp[i][j][1]=count2%mod;
            }
        
        return dp[0][n-1][0];
        
            
        
        
    }
    
    //i=0,j=s1.length()-1,flag=desired
    //dp(i,j)：表示s[i...j]达到flag的方案数
    public static int dp(int[] nums,char[] ops,int i,int j,boolean flag){
        
//         if(i>j) return 0;
        
        int count=0;
        //选择
//         int solu1=dp(nums,ops,i+1,j,true);
//         int solu2=dp(nums,ops,i,j-1);
        boolean fi=nums[i]==1?true:false;
        boolean fj=nums[j]==1?true:false;
        
        if(i==j){
            if(fi==flag) return 1;
            else return 0;
        }
        
        
        boolean res1=operate(fi,flag,ops[i]);
        if(res1==flag) count+=dp(nums,ops,i+1,j,flag);
        
        boolean res1_1=operate(fi,!flag,ops[i]);
        if(res1_1==(!flag)) count+=dp(nums,ops,i+1,j,!flag);
        
        boolean res2=operate(fj,flag,ops[j-1]);
        if(res2==flag) count+=dp(nums,ops,i,j-1,flag);
        
        boolean res2_1=operate(fj,!flag,ops[j-1]);
        if(res2_1==(!flag)) count+=dp(nums,ops,i,j-1,!flag);
        
        return count%(int)mod;
    }
    
    
    public static boolean operate(boolean f1,boolean f2,char op){

        if(op=='^') return f1==f2?false:true;
        if(op=='|') return f1||f2;
        if(op=='&') return f1&&f2;
        return false;
    }
    
//     public static boolean operate(char c1,char c2,char op){
//         boolean f1=false,f2=false;
//         if(c1==1) f1=true;
//         if(c2==1) f2=true;
        
//         if(op=='^') return f1==f2?false:true;
//         if(op=='|') return f1||f2;
//         if(op=='&') return f1&&f2;
//         return false;
//     }
}
```



# 字符串问题



## CD95 判断两个字符串是否为变形词

https://www.nowcoder.com/practice/b07c464a107e421ebbd2c82aebd42e39?tpId=101&&tqId=33163&rp=1&ru=/ta/programmer-code-interview-guide&qru=/ta/programmer-code-interview-guide/question-ranking



```java
import java.util.Scanner;
import java.util.HashMap;
public class Main{
    public static void main(String[] args){
        Scanner sc=new Scanner(System.in);
        sc.nextInt();sc.nextInt();
        
        String s1=sc.next(),s2=sc.next();

        HashMap<Character,Integer> map1=new HashMap<>();
        for(char c:s1.toCharArray()){
            map1.put(c,map1.getOrDefault(c,0)+1);
        }
        
        HashMap<Character,Integer> map2=new HashMap<>();
        for(char c:s2.toCharArray()){
            map2.put(c,map2.getOrDefault(c,0)+1);
        }
        
        for(char c:map1.keySet()){
            if(!map1.get(c).equals(map2.getOrDefault(c,-1))){
                System.out.println("false");
                return;
            }
        }
        System.out.println("true");
               
    }
    
}
```





## CD96 判断两个字符串是否互为旋转词

https://www.nowcoder.com/practice/687deda2cc57473499e058207f6258cf?tpId=101&tags=&title=&difficulty=0&judgeStatus=0&rp=1



```java
import java.util.Scanner;
import java.util.HashMap;
public class Main{
    public static void main(String[] args){
        Scanner sc=new Scanner(System.in);
        int m=sc.nextInt(),n=sc.nextInt();
        if(m!=n){
            System.out.println("NO");
            return;
        }
        
        String s1=sc.next(),s2=sc.next();
        
        int i1=0,i2=0;
        for(;i1<s1.length();i1++){
            if(s1.charAt(i1)==s2.charAt(i2)) break;
        }
        
        if(i1==s1.length()){
            System.out.println("NO");
            return;
        }
        
        while(i1<s1.length() && i2<s2.length()){
            if(s1.charAt(i1)!=s2.charAt(i2)){
                System.out.println("NO");
                return;
            }
            i1++;
            i2++;
        }
        i1=0;
        
        while(i1<s1.length() && i2<s2.length()){
            if(s1.charAt(i1)!=s2.charAt(i2)){
                System.out.println("NO");
                return;
            }
            i1++;
            i2++;
        }
        System.out.println("YES");
        
        
    }
    
}
```



## CD97 将整数字符串转成整数值

https://www.nowcoder.com/practice/0c630b57e3d144379508d63d8eb65854?tpId=101&&tqId=33165&rp=1&ru=/ta/programmer-code-interview-guide&qru=/ta/programmer-code-interview-guide/question-ranking



```java
import java.util.Scanner;

public class Main{
    static String maxInt="2147483647";
    
    static boolean flag=false;//是否是负数
    public static void main(String[] args){
        Scanner sc=new Scanner(System.in);
        String s=sc.next();
        if(s.charAt(0)=='-'){
            s=s.substring(1,s.length());
            flag=true;
        }
        
        if(s.length()<1 || s.length()>10 || s.charAt(0)=='0'){//别忘记了0
            System.out.println("0");
            return;
        }
        
        
        for(char c:s.toCharArray()){//判断数字
            if(!Character.isDigit(c)){
                System.out.println("0");
                return;
            }
        }
        
        if(s.length()<10){
            System.out.println(flag?("-"+s):(s));
            return;
        }
        
        //这里就是10位
        boolean res=judgeNum(s,0);
        if(res){
            System.out.println(flag?("-"+s):(s));
        }else{
            System.out.println("0");
        }

    }
    
    //index=0
    public static boolean judgeNum(String s,int index){
        if(index>=10) return true;
        
        if(index==9 && flag){//最后一位，并且是负数
            if(s.charAt(index)<='8'){
                return true;
            }else{
                return false;
            }
        }
        
        if(s.charAt(index)<=maxInt.charAt(index)){
            return judgeNum(s,index+1);
        }else{
            return false;
        }
        
    }
}
```



## CD98 字符串的统计字符串

https://www.nowcoder.com/practice/e8b97a6d64ae4304b6f0ff4ecae1589d?tpId=101&&tqId=33166&rp=1&ru=/ta/programmer-code-interview-guide&qru=/ta/programmer-code-interview-guide/question-ranking



```java
import java.util.Scanner;
import java.util.LinkedHashMap;
public class Main{
    public static void main(String[] args){
        Scanner sc=new Scanner(System.in);
        String s=sc.next();

        char[] arr=s.toCharArray();
        int count=1;
        for(int i=0;i<arr.length-1;i++){
            if(arr[i]==arr[i+1]){
                count++;
            }else{
                System.out.print(arr[i]+"_"+count+"_");
                count=1;
            }
        }
        System.out.print(arr[arr.length-1]+"_"+count);
        
    }
}
```



## CD116 翻转字符串（1）

https://www.nowcoder.com/practice/972117dd8f334076a5df6a68b0a8f3dd?tpId=101&&tqId=33184&rp=1&ru=/ta/programmer-code-interview-guide&qru=/ta/programmer-code-interview-guide/question-ranking



```java
import java.util.Scanner;
import java.util.LinkedHashMap;
public class Main{
    public static void main(String[] args){
        Scanner sc=new Scanner(System.in);
        String s=sc.nextLine();
        String[] arr=s.split("[ ]");
        
        
        for(String t:arr){
            //StringBuilder buf=new StringBuilder(t);
            System.out.print(reverse(t)+" ");
        }
    }
    public static String reverse(String s){
        if(s.length()==1) return s;
        return s.charAt(s.length()-1)+reverse(s.substring(0,s.length()-1));
    }
}
```





## CD121 删除多余的字符得到字典





我的两个思路都不对：

1. 记录每一个字母出现的位置，对出现次数大于2的进行删除。
   不对，因为删除后记录的位置就变动了，就不对了

2. 记录每一个字母出现的位置，按对记录的字母从小到大排序，对出现次数大于2的进行删除。

   ```java
   HashMap<Character,ArrayList<Integer>> map=new HashMap<>();
   for(int i=0;i<arr.length;i++){
       ArrayList<Integer> list=map.getOrDefault(arr[i],new ArrayList<>());
       list.add(i);
       map.put(arr[i],list);
   }
   
   Character[] chars=map.keySet().toArray(new Character[0]);
   Arrays.sort(chars);
   ```

   不对，因为当删除一个字母时，由于其它重复的字母还存在，所以不能保证**当前删除字母后的字符串再最后也是最小的**



第1个想法实现方式

```java
import java.util.Scanner;
import java.util.HashMap;
import java.util.ArrayList;
public class Main{

    public static void main(String[] args){
        Scanner sc=new Scanner(System.in);
        String s=sc.next();
        //记录每一个字母出现的位置 （这个方法不行，因为s始终是变动的）
        HashMap<Character,ArrayList<Integer>> map=new HashMap<>();
        for(int i=0;i<s.length();i++){
            ArrayList<Integer> list=map.getOrDefault(s.charAt(i),new ArrayList<>());
            list.add(i);
            map.put(s.charAt(i),list);
        }
        
        int len=s.length();
        for(int i=0;i<len;i++){
            if(map.get(s.charAt(i))!=null && map.get(s.charAt(i)).size()>=2){
                ArrayList<Integer> list=map.get(s.charAt(i));
                int min=list.get(0);
                
                int offset=0;
                for(int k=1;k<list.size();k++){
                    String s1=s.substring(0,k-offset)+s.substring(k+1-offset,s.length());
                    String s2=s.substring(0,min)+s.substring(min+1,s.length());
                    if((s1).compareTo(s2)<0){
                        min=min;
                        s=s1;//移除k
                    }else{
                        s=s2;//移除m
                        min=k-1;
                    }
                    offset++;
                    //min=(s1).compareTo(s2)<0?k:min;
                }
//                 int offset=0;
//                 for(int k=0;k<list.size();k++){
//                     if(k==min) continue;
//                     s=s.substring(0,k)+s.substring(k+1,s.length());
//                 }
                list.clear();
                len=s.length();
                i--;
            }
            
        }
        
        System.out.println(s);
        
        
    }
}
```



## CD121 删除多余的字符得到字典序最小的字符串



https://www.nowcoder.com/practice/611d16ddd5344bfdb76c22306247dcf3?tpId=101&&tqId=33189&rp=1&ru=/ta/programmer-code-interview-guide&qru=/ta/programmer-code-interview-guide/question-ranking

用的左神的思想，自己的实现，这个确实挺难的，调试了一个多小时



```java
import java.util.Scanner;
import java.util.HashMap;
import java.util.ArrayList;
import java.util.Arrays;
public class Main{

    public static void main(String[] args){
        Scanner sc=new Scanner(System.in);
        String s=sc.next();
        char[] arr=s.toCharArray();
        int n=arr.length;
        
        HashMap<Character,Integer> map=new HashMap<>();
        for(char c:arr){
            map.put(c,map.getOrDefault(c,0)+1);
        }
        
        char[] res=new char[map.keySet().size()];
        int resi=0;
        
        int initIndex=0;
        int curIndex=0;
        while(curIndex<n){
            int count=map.getOrDefault(arr[curIndex],-1);
            if(count>=2 || count<=-1){ //<=-1代表已经移除的
                map.put(arr[curIndex],count-1);
                curIndex++;
                continue;
            }
            map.put(arr[curIndex],count-1); //坑1：当值为1时一定要减为0
            
            //这里 当前只剩一个了
            char minChar='z'+1; //坑2：不要把minChar设置为arr[initIndex]，因为arr[initIndex]可能已经移除了。
            int findCharIndex=-1;
            
            for(int i=initIndex;i<=curIndex;i++){
                if(map.getOrDefault(arr[i],-1)>=0){//坑三：这里要>=0，而不是>=-1
                    if(arr[i]<minChar){
                        minChar=arr[i];
                        findCharIndex=i;
                    }
                }
            }
            
            res[resi++]=arr[findCharIndex];
            
            map.remove(arr[findCharIndex]);
            
            //恢复，准备下一次遍历
            
            for(int i=findCharIndex+1;i<=curIndex;i++){
                if(map.getOrDefault(arr[i],-1)>=0){//把之前减的加回来,//坑三：这里要>=0，而不是>=-1
                    map.put(arr[i],map.get(arr[i])+1);
                }
            }
            
            initIndex=findCharIndex+1;
            curIndex=findCharIndex+1;
            
        }
        
        System.out.println(new String(res));
        
        
        
        
        
        
    }
}
```



## CD122 数组中两个字符串的最小距离

https://www.nowcoder.com/practice/2c6a0a8e1d20492f92941400036e0890?tpId=101&&tqId=33190&rp=1&ru=/ta/programmer-code-interview-guide&qru=/ta/programmer-code-interview-guide/question-ranking









```java
import java.util.Scanner;

public class Main{
    
    public static void main(String[] args){
        Scanner sc=new Scanner(System.in);
        int n=sc.nextInt();
        String s1=sc.next(),s2=sc.next();
        
        int minDis=Integer.MAX_VALUE;
        int l1=-1,l2=-1;
        String s="";
        for(int i=0;i<n;i++){
            s=sc.next();
            if(s.equals(s1)){
                l1=i;
                if(l2!=-1){
                    if(Math.abs(l1-l2)<minDis) minDis=(int)Math.abs(l1-l2);
                }
            }else if(s.equals(s2)){
                l2=i;
                if(l1!=-1){
                    if(Math.abs(l1-l2)<minDis) minDis=(int)Math.abs(l1-l2);
                }
            }
        }
        
        if(l1==-1 || l2==-1){
            System.out.print(-1);
        }else{
            System.out.print(minDis);
        }
        
        
        
    }
}
```

